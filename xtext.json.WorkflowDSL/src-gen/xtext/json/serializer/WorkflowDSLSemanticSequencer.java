/*
 * generated by Xtext 2.40.0
 */
package xtext.json.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.json.services.WorkflowDSLGrammarAccess;
import xtext.json.workflowDSL.AdvancedImpute;
import xtext.json.workflowDSL.BinDef;
import xtext.json.workflowDSL.BinDefinitions;
import xtext.json.workflowDSL.BinMode;
import xtext.json.workflowDSL.BinName;
import xtext.json.workflowDSL.Binner;
import xtext.json.workflowDSL.BoundValue;
import xtext.json.workflowDSL.CSVReader;
import xtext.json.workflowDSL.CastTypeCheck;
import xtext.json.workflowDSL.CastTypeContract;
import xtext.json.workflowDSL.Column;
import xtext.json.workflowDSL.ColumnFilter;
import xtext.json.workflowDSL.ColumnList;
import xtext.json.workflowDSL.ConditionContract;
import xtext.json.workflowDSL.ContractBlock;
import xtext.json.workflowDSL.ContractBody;
import xtext.json.workflowDSL.ContractField;
import xtext.json.workflowDSL.ContractName;
import xtext.json.workflowDSL.ContractValue;
import xtext.json.workflowDSL.DataSource;
import xtext.json.workflowDSL.DateFormat;
import xtext.json.workflowDSL.Delimiter;
import xtext.json.workflowDSL.FilePath;
import xtext.json.workflowDSL.FileReader;
import xtext.json.workflowDSL.FixedImpute;
import xtext.json.workflowDSL.FunctionCall;
import xtext.json.workflowDSL.IQRMethod;
import xtext.json.workflowDSL.IQRParams;
import xtext.json.workflowDSL.IfClause;
import xtext.json.workflowDSL.Imputation;
import xtext.json.workflowDSL.Interval;
import xtext.json.workflowDSL.IntervalBound;
import xtext.json.workflowDSL.Invariant;
import xtext.json.workflowDSL.Join;
import xtext.json.workflowDSL.JoinCondition;
import xtext.json.workflowDSL.JoinConditions;
import xtext.json.workflowDSL.JoinOptions;
import xtext.json.workflowDSL.JoinSpec;
import xtext.json.workflowDSL.MappingMode;
import xtext.json.workflowDSL.MappingRule;
import xtext.json.workflowDSL.MappingRules;
import xtext.json.workflowDSL.MathOp;
import xtext.json.workflowDSL.MissingFilter;
import xtext.json.workflowDSL.Operand;
import xtext.json.workflowDSL.OutlierOptions;
import xtext.json.workflowDSL.OutlierStrategy;
import xtext.json.workflowDSL.OutlierTreatment;
import xtext.json.workflowDSL.Pattern;
import xtext.json.workflowDSL.PercentileMethod;
import xtext.json.workflowDSL.Postcondition;
import xtext.json.workflowDSL.Precondition;
import xtext.json.workflowDSL.Primary;
import xtext.json.workflowDSL.RangeBounds;
import xtext.json.workflowDSL.RangeFilter;
import xtext.json.workflowDSL.Regex;
import xtext.json.workflowDSL.ReplacementStrategy;
import xtext.json.workflowDSL.RowFilter;
import xtext.json.workflowDSL.SpecialValueContract;
import xtext.json.workflowDSL.Step;
import xtext.json.workflowDSL.StringFilter;
import xtext.json.workflowDSL.SubstringMapping;
import xtext.json.workflowDSL.ThenClause;
import xtext.json.workflowDSL.TypeConversion;
import xtext.json.workflowDSL.Value;
import xtext.json.workflowDSL.ValueCheck;
import xtext.json.workflowDSL.ValueList;
import xtext.json.workflowDSL.ValueMapping;
import xtext.json.workflowDSL.ValueRangeContract;
import xtext.json.workflowDSL.Workflow;
import xtext.json.workflowDSL.WorkflowBody;
import xtext.json.workflowDSL.WorkflowDSLPackage;
import xtext.json.workflowDSL.ZScoreMethod;

@SuppressWarnings("all")
public class WorkflowDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private WorkflowDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == WorkflowDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case WorkflowDSLPackage.ADVANCED_IMPUTE:
				sequence_AdvancedImpute(context, (AdvancedImpute) semanticObject); 
				return; 
			case WorkflowDSLPackage.BIN_DEF:
				sequence_BinDef(context, (BinDef) semanticObject); 
				return; 
			case WorkflowDSLPackage.BIN_DEFINITIONS:
				sequence_BinDefinitions(context, (BinDefinitions) semanticObject); 
				return; 
			case WorkflowDSLPackage.BIN_MODE:
				sequence_BinMode(context, (BinMode) semanticObject); 
				return; 
			case WorkflowDSLPackage.BIN_NAME:
				sequence_BinName(context, (BinName) semanticObject); 
				return; 
			case WorkflowDSLPackage.BINNER:
				sequence_Binner(context, (Binner) semanticObject); 
				return; 
			case WorkflowDSLPackage.BOUND_VALUE:
				sequence_BoundValue(context, (BoundValue) semanticObject); 
				return; 
			case WorkflowDSLPackage.CSV_READER:
				sequence_CSVReader(context, (CSVReader) semanticObject); 
				return; 
			case WorkflowDSLPackage.CAST_TYPE_CHECK:
				sequence_CastTypeCheck(context, (CastTypeCheck) semanticObject); 
				return; 
			case WorkflowDSLPackage.CAST_TYPE_CONTRACT:
				sequence_CastTypeContract(context, (CastTypeContract) semanticObject); 
				return; 
			case WorkflowDSLPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case WorkflowDSLPackage.COLUMN_FILTER:
				sequence_ColumnFilter(context, (ColumnFilter) semanticObject); 
				return; 
			case WorkflowDSLPackage.COLUMN_LIST:
				sequence_ColumnList(context, (ColumnList) semanticObject); 
				return; 
			case WorkflowDSLPackage.CONDITION_CONTRACT:
				sequence_ConditionContract(context, (ConditionContract) semanticObject); 
				return; 
			case WorkflowDSLPackage.CONTRACT_BLOCK:
				sequence_ContractBlock(context, (ContractBlock) semanticObject); 
				return; 
			case WorkflowDSLPackage.CONTRACT_BODY:
				sequence_ContractBody(context, (ContractBody) semanticObject); 
				return; 
			case WorkflowDSLPackage.CONTRACT_FIELD:
				sequence_ContractField(context, (ContractField) semanticObject); 
				return; 
			case WorkflowDSLPackage.CONTRACT_NAME:
				sequence_ContractName(context, (ContractName) semanticObject); 
				return; 
			case WorkflowDSLPackage.CONTRACT_VALUE:
				sequence_ContractValue(context, (ContractValue) semanticObject); 
				return; 
			case WorkflowDSLPackage.DATA_SOURCE:
				sequence_DataSource(context, (DataSource) semanticObject); 
				return; 
			case WorkflowDSLPackage.DATE_FORMAT:
				sequence_DateFormat(context, (DateFormat) semanticObject); 
				return; 
			case WorkflowDSLPackage.DELIMITER:
				sequence_Delimiter(context, (Delimiter) semanticObject); 
				return; 
			case WorkflowDSLPackage.FILE_PATH:
				sequence_FilePath(context, (FilePath) semanticObject); 
				return; 
			case WorkflowDSLPackage.FILE_READER:
				sequence_FileReader(context, (FileReader) semanticObject); 
				return; 
			case WorkflowDSLPackage.FIXED_IMPUTE:
				sequence_FixedImpute(context, (FixedImpute) semanticObject); 
				return; 
			case WorkflowDSLPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case WorkflowDSLPackage.IQR_METHOD:
				sequence_IQRMethod(context, (IQRMethod) semanticObject); 
				return; 
			case WorkflowDSLPackage.IQR_PARAMS:
				sequence_IQRParams(context, (IQRParams) semanticObject); 
				return; 
			case WorkflowDSLPackage.IF_CLAUSE:
				sequence_IfClause(context, (IfClause) semanticObject); 
				return; 
			case WorkflowDSLPackage.IMPUTATION:
				sequence_Imputation(context, (Imputation) semanticObject); 
				return; 
			case WorkflowDSLPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case WorkflowDSLPackage.INTERVAL_BOUND:
				sequence_IntervalBound(context, (IntervalBound) semanticObject); 
				return; 
			case WorkflowDSLPackage.INVARIANT:
				sequence_Invariant(context, (Invariant) semanticObject); 
				return; 
			case WorkflowDSLPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case WorkflowDSLPackage.JOIN_CONDITION:
				sequence_JoinCondition(context, (JoinCondition) semanticObject); 
				return; 
			case WorkflowDSLPackage.JOIN_CONDITIONS:
				sequence_JoinConditions(context, (JoinConditions) semanticObject); 
				return; 
			case WorkflowDSLPackage.JOIN_OPTIONS:
				sequence_JoinOptions(context, (JoinOptions) semanticObject); 
				return; 
			case WorkflowDSLPackage.JOIN_SPEC:
				sequence_JoinSpec(context, (JoinSpec) semanticObject); 
				return; 
			case WorkflowDSLPackage.MAPPING_MODE:
				sequence_MappingMode(context, (MappingMode) semanticObject); 
				return; 
			case WorkflowDSLPackage.MAPPING_RULE:
				sequence_MappingRule(context, (MappingRule) semanticObject); 
				return; 
			case WorkflowDSLPackage.MAPPING_RULES:
				sequence_MappingRules(context, (MappingRules) semanticObject); 
				return; 
			case WorkflowDSLPackage.MATH_OP:
				sequence_MathOp(context, (MathOp) semanticObject); 
				return; 
			case WorkflowDSLPackage.MISSING_FILTER:
				sequence_MissingFilter(context, (MissingFilter) semanticObject); 
				return; 
			case WorkflowDSLPackage.OPERAND:
				sequence_Operand(context, (Operand) semanticObject); 
				return; 
			case WorkflowDSLPackage.OUTLIER_OPTIONS:
				sequence_OutlierOptions(context, (OutlierOptions) semanticObject); 
				return; 
			case WorkflowDSLPackage.OUTLIER_STRATEGY:
				sequence_OutlierStrategy(context, (OutlierStrategy) semanticObject); 
				return; 
			case WorkflowDSLPackage.OUTLIER_TREATMENT:
				sequence_OutlierTreatment(context, (OutlierTreatment) semanticObject); 
				return; 
			case WorkflowDSLPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case WorkflowDSLPackage.PERCENTILE_METHOD:
				sequence_PercentileMethod(context, (PercentileMethod) semanticObject); 
				return; 
			case WorkflowDSLPackage.POSTCONDITION:
				sequence_Postcondition(context, (Postcondition) semanticObject); 
				return; 
			case WorkflowDSLPackage.PRECONDITION:
				sequence_Precondition(context, (Precondition) semanticObject); 
				return; 
			case WorkflowDSLPackage.PRIMARY:
				if (rule == grammarAccess.getMathExpressionRule()) {
					sequence_MathExpression_Primary(context, (Primary) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryRule()) {
					sequence_Primary(context, (Primary) semanticObject); 
					return; 
				}
				else break;
			case WorkflowDSLPackage.RANGE_BOUNDS:
				sequence_RangeBounds(context, (RangeBounds) semanticObject); 
				return; 
			case WorkflowDSLPackage.RANGE_FILTER:
				sequence_RangeFilter(context, (RangeFilter) semanticObject); 
				return; 
			case WorkflowDSLPackage.REGEX:
				sequence_Regex(context, (Regex) semanticObject); 
				return; 
			case WorkflowDSLPackage.REPLACEMENT_STRATEGY:
				sequence_ReplacementStrategy(context, (ReplacementStrategy) semanticObject); 
				return; 
			case WorkflowDSLPackage.ROW_FILTER:
				sequence_RowFilter(context, (RowFilter) semanticObject); 
				return; 
			case WorkflowDSLPackage.SPECIAL_VALUE_CONTRACT:
				sequence_SpecialValueContract(context, (SpecialValueContract) semanticObject); 
				return; 
			case WorkflowDSLPackage.STEP:
				sequence_Step(context, (Step) semanticObject); 
				return; 
			case WorkflowDSLPackage.STRING_FILTER:
				sequence_StringFilter(context, (StringFilter) semanticObject); 
				return; 
			case WorkflowDSLPackage.SUBSTRING_MAPPING:
				sequence_SubstringMapping(context, (SubstringMapping) semanticObject); 
				return; 
			case WorkflowDSLPackage.THEN_CLAUSE:
				sequence_ThenClause(context, (ThenClause) semanticObject); 
				return; 
			case WorkflowDSLPackage.TYPE_CONVERSION:
				sequence_TypeConversion(context, (TypeConversion) semanticObject); 
				return; 
			case WorkflowDSLPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case WorkflowDSLPackage.VALUE_CHECK:
				sequence_ValueCheck(context, (ValueCheck) semanticObject); 
				return; 
			case WorkflowDSLPackage.VALUE_LIST:
				sequence_ValueList(context, (ValueList) semanticObject); 
				return; 
			case WorkflowDSLPackage.VALUE_MAPPING:
				sequence_ValueMapping(context, (ValueMapping) semanticObject); 
				return; 
			case WorkflowDSLPackage.VALUE_RANGE_CONTRACT:
				sequence_ValueRangeContract(context, (ValueRangeContract) semanticObject); 
				return; 
			case WorkflowDSLPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			case WorkflowDSLPackage.WORKFLOW_BODY:
				sequence_WorkflowBody(context, (WorkflowBody) semanticObject); 
				return; 
			case WorkflowDSLPackage.ZSCORE_METHOD:
				sequence_ZScoreMethod(context, (ZScoreMethod) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImputeMethod returns AdvancedImpute
	 *     AdvancedImpute returns AdvancedImpute
	 *
	 * Constraint:
	 *     (type=InterpolationType | windowSize=Number | degree=Number)
	 * </pre>
	 */
	protected void sequence_AdvancedImpute(ISerializationContext context, AdvancedImpute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinDef returns BinDef
	 *
	 * Constraint:
	 *     (name=BinName interval=Interval)
	 * </pre>
	 */
	protected void sequence_BinDef(ISerializationContext context, BinDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.BIN_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.BIN_DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.BIN_DEF__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.BIN_DEF__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinDefAccess().getNameBinNameParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBinDefAccess().getIntervalIntervalParserRuleCall_2_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinDefinitions returns BinDefinitions
	 *
	 * Constraint:
	 *     (definitions+=BinDef definitions+=BinDef*)
	 * </pre>
	 */
	protected void sequence_BinDefinitions(ISerializationContext context, BinDefinitions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinMode returns BinMode
	 *
	 * Constraint:
	 *     newName=ID
	 * </pre>
	 */
	protected void sequence_BinMode(ISerializationContext context, BinMode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.BIN_MODE__NEW_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.BIN_MODE__NEW_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinModeAccess().getNewNameIDTerminalRuleCall_1_1_0(), semanticObject.getNewName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinName returns BinName
	 *
	 * Constraint:
	 *     name=STRING
	 * </pre>
	 */
	protected void sequence_BinName(ISerializationContext context, BinName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.BIN_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.BIN_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinNameAccess().getNameSTRINGTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns Binner
	 *     Binner returns Binner
	 *
	 * Constraint:
	 *     (column=Column definitions=BinDefinitions mode=BinMode)
	 * </pre>
	 */
	protected void sequence_Binner(ISerializationContext context, Binner semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.BINNER__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.BINNER__COLUMN));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.BINNER__DEFINITIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.BINNER__DEFINITIONS));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.BINNER__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.BINNER__MODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinnerAccess().getColumnColumnParserRuleCall_2_0(), semanticObject.getColumn());
		feeder.accept(grammarAccess.getBinnerAccess().getDefinitionsBinDefinitionsParserRuleCall_5_0(), semanticObject.getDefinitions());
		feeder.accept(grammarAccess.getBinnerAccess().getModeBinModeParserRuleCall_7_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BoundValue returns BoundValue
	 *
	 * Constraint:
	 *     value=Number
	 * </pre>
	 */
	protected void sequence_BoundValue(ISerializationContext context, BoundValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.BOUND_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.BOUND_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoundValueAccess().getValueNumberParserRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataReader returns CSVReader
	 *     CSVReader returns CSVReader
	 *
	 * Constraint:
	 *     (filePath=FilePath delimiter=Delimiter?)
	 * </pre>
	 */
	protected void sequence_CSVReader(ISerializationContext context, CSVReader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataCondition returns CastTypeCheck
	 *     CastTypeCheck returns CastTypeCheck
	 *     DataResult returns CastTypeCheck
	 *
	 * Constraint:
	 *     type=Type
	 * </pre>
	 */
	protected void sequence_CastTypeCheck(ISerializationContext context, CastTypeCheck semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CAST_TYPE_CHECK__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CAST_TYPE_CHECK__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCastTypeCheckAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractType returns CastTypeContract
	 *     CastTypeContract returns CastTypeContract
	 *
	 * Constraint:
	 *     ((type=Type field=ContractField) | (type=Type field=ContractField))
	 * </pre>
	 */
	protected void sequence_CastTypeContract(ISerializationContext context, CastTypeContract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns ColumnFilter
	 *     ColumnFilter returns ColumnFilter
	 *
	 * Constraint:
	 *     (columns=ColumnList | columns=ColumnList | columns=ColumnList | columns=ColumnList)
	 * </pre>
	 */
	protected void sequence_ColumnFilter(ISerializationContext context, ColumnFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ColumnList returns ColumnList
	 *
	 * Constraint:
	 *     (columns+=Column columns+=Column*)
	 * </pre>
	 */
	protected void sequence_ColumnList(ISerializationContext context, ColumnList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (name=ID | (table=ID column=ID))
	 * </pre>
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractType returns ConditionContract
	 *     ConditionContract returns ConditionContract
	 *
	 * Constraint:
	 *     (ifClause=IfClause thenClause=ThenClause)
	 * </pre>
	 */
	protected void sequence_ConditionContract(ISerializationContext context, ConditionContract semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CONDITION_CONTRACT__IF_CLAUSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CONDITION_CONTRACT__IF_CLAUSE));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CONDITION_CONTRACT__THEN_CLAUSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CONDITION_CONTRACT__THEN_CLAUSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionContractAccess().getIfClauseIfClauseParserRuleCall_2_0(), semanticObject.getIfClause());
		feeder.accept(grammarAccess.getConditionContractAccess().getThenClauseThenClauseParserRuleCall_3_0(), semanticObject.getThenClause());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractBlock returns ContractBlock
	 *
	 * Constraint:
	 *     contracts+=Contract+
	 * </pre>
	 */
	protected void sequence_ContractBlock(ISerializationContext context, ContractBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractBody returns ContractBody
	 *
	 * Constraint:
	 *     type=ContractType
	 * </pre>
	 */
	protected void sequence_ContractBody(ISerializationContext context, ContractBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CONTRACT_BODY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CONTRACT_BODY__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContractBodyAccess().getTypeContractTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractField returns ContractField
	 *
	 * Constraint:
	 *     (column=Column | column=Column)
	 * </pre>
	 */
	protected void sequence_ContractField(ISerializationContext context, ContractField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractName returns ContractName
	 *
	 * Constraint:
	 *     (name=STRING | name=ID)
	 * </pre>
	 */
	protected void sequence_ContractName(ISerializationContext context, ContractName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractValue returns ContractValue
	 *
	 * Constraint:
	 *     (type=Type | bounds=RangeBounds | value=Value)
	 * </pre>
	 */
	protected void sequence_ContractValue(ISerializationContext context, ContractValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataSource returns DataSource
	 *
	 * Constraint:
	 *     (name=ID reader=DataReader)
	 * </pre>
	 */
	protected void sequence_DataSource(ISerializationContext context, DataSource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.DATA_SOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.DATA_SOURCE__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.DATA_SOURCE__READER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.DATA_SOURCE__READER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataSourceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDataSourceAccess().getReaderDataReaderParserRuleCall_3_0(), semanticObject.getReader());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DateFormat returns DateFormat
	 *
	 * Constraint:
	 *     format=STRING
	 * </pre>
	 */
	protected void sequence_DateFormat(ISerializationContext context, DateFormat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.DATE_FORMAT__FORMAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.DATE_FORMAT__FORMAT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateFormatAccess().getFormatSTRINGTerminalRuleCall_2_0(), semanticObject.getFormat());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Delimiter returns Delimiter
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Delimiter(ISerializationContext context, Delimiter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.DELIMITER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.DELIMITER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDelimiterAccess().getValueSTRINGTerminalRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FilePath returns FilePath
	 *
	 * Constraint:
	 *     path=STRING
	 * </pre>
	 */
	protected void sequence_FilePath(ISerializationContext context, FilePath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.FILE_PATH__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.FILE_PATH__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFilePathAccess().getPathSTRINGTerminalRuleCall_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataReader returns FileReader
	 *     FileReader returns FileReader
	 *
	 * Constraint:
	 *     filePath=FilePath
	 * </pre>
	 */
	protected void sequence_FileReader(ISerializationContext context, FileReader semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.DATA_READER__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.DATA_READER__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFileReaderAccess().getFilePathFilePathParserRuleCall_2_0(), semanticObject.getFilePath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImputeMethod returns FixedImpute
	 *     FixedImpute returns FixedImpute
	 *
	 * Constraint:
	 *     values=ValueList
	 * </pre>
	 */
	protected void sequence_FixedImpute(ISerializationContext context, FixedImpute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.FIXED_IMPUTE__VALUES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.FIXED_IMPUTE__VALUES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFixedImputeAccess().getValuesValueListParserRuleCall_2_0(), semanticObject.getValues());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (function=Function (operands+=Operand operands+=Operand*)?)
	 * </pre>
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DetectionMethod returns IQRMethod
	 *     IQRMethod returns IQRMethod
	 *
	 * Constraint:
	 *     params=IQRParams
	 * </pre>
	 */
	protected void sequence_IQRMethod(ISerializationContext context, IQRMethod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.IQR_METHOD__PARAMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.IQR_METHOD__PARAMS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIQRMethodAccess().getParamsIQRParamsParserRuleCall_1_0(), semanticObject.getParams());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IQRParams returns IQRParams
	 *
	 * Constraint:
	 *     (scalar=Number | estimation=EstimationType)
	 * </pre>
	 */
	protected void sequence_IQRParams(ISerializationContext context, IQRParams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfClause returns IfClause
	 *
	 * Constraint:
	 *     (field=ContractField op=BelongOp condition=DataCondition)
	 * </pre>
	 */
	protected void sequence_IfClause(ISerializationContext context, IfClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.IF_CLAUSE__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.IF_CLAUSE__FIELD));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.IF_CLAUSE__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.IF_CLAUSE__OP));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.IF_CLAUSE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.IF_CLAUSE__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfClauseAccess().getFieldContractFieldParserRuleCall_1_0(), semanticObject.getField());
		feeder.accept(grammarAccess.getIfClauseAccess().getOpBelongOpParserRuleCall_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getIfClauseAccess().getConditionDataConditionParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns Imputation
	 *     Imputation returns Imputation
	 *
	 * Constraint:
	 *     (columns=ColumnList method=ImputeMethod)
	 * </pre>
	 */
	protected void sequence_Imputation(ISerializationContext context, Imputation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.IMPUTATION__COLUMNS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.IMPUTATION__COLUMNS));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.IMPUTATION__METHOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.IMPUTATION__METHOD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImputationAccess().getColumnsColumnListParserRuleCall_2_0(), semanticObject.getColumns());
		feeder.accept(grammarAccess.getImputationAccess().getMethodImputeMethodParserRuleCall_5_0(), semanticObject.getMethod());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntervalBound returns IntervalBound
	 *
	 * Constraint:
	 *     value=Number
	 * </pre>
	 */
	protected void sequence_IntervalBound(ISerializationContext context, IntervalBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.INTERVAL_BOUND__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.INTERVAL_BOUND__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalBoundAccess().getValueNumberParserRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     (
	 *         (lower=IntervalBound upper=IntervalBound) | 
	 *         (lower=IntervalBound upper=IntervalBound) | 
	 *         (lower=IntervalBound upper=IntervalBound) | 
	 *         (lower=IntervalBound upper=IntervalBound)
	 *     )
	 * </pre>
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Contract returns Invariant
	 *     Invariant returns Invariant
	 *
	 * Constraint:
	 *     (name=ContractName body=ContractBody)
	 * </pre>
	 */
	protected void sequence_Invariant(ISerializationContext context, Invariant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvariantAccess().getNameContractNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInvariantAccess().getBodyContractBodyParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JoinCondition returns JoinCondition
	 *
	 * Constraint:
	 *     ((left=Column right=Column) | (left=Column comparator=Comparator right=Column))
	 * </pre>
	 */
	protected void sequence_JoinCondition(ISerializationContext context, JoinCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JoinConditions returns JoinConditions
	 *
	 * Constraint:
	 *     (conditions+=JoinCondition conditions+=JoinCondition*)
	 * </pre>
	 */
	protected void sequence_JoinConditions(ISerializationContext context, JoinConditions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JoinOptions returns JoinOptions
	 *
	 * Constraint:
	 *     (leftSuffix=STRING rightSuffix=STRING)
	 * </pre>
	 */
	protected void sequence_JoinOptions(ISerializationContext context, JoinOptions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.JOIN_OPTIONS__LEFT_SUFFIX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.JOIN_OPTIONS__LEFT_SUFFIX));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.JOIN_OPTIONS__RIGHT_SUFFIX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.JOIN_OPTIONS__RIGHT_SUFFIX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJoinOptionsAccess().getLeftSuffixSTRINGTerminalRuleCall_3_0(), semanticObject.getLeftSuffix());
		feeder.accept(grammarAccess.getJoinOptionsAccess().getRightSuffixSTRINGTerminalRuleCall_5_0(), semanticObject.getRightSuffix());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JoinSpec returns JoinSpec
	 *
	 * Constraint:
	 *     (type=JoinType conditions=JoinConditions options=JoinOptions?)
	 * </pre>
	 */
	protected void sequence_JoinSpec(ISerializationContext context, JoinSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (left=ID right=ID spec=JoinSpec)
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.JOIN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.JOIN__LEFT));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.JOIN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.JOIN__RIGHT));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.JOIN__SPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.JOIN__SPEC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJoinAccess().getLeftIDTerminalRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getJoinAccess().getRightIDTerminalRuleCall_4_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getJoinAccess().getSpecJoinSpecParserRuleCall_7_0(), semanticObject.getSpec());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MappingMode returns MappingMode
	 *
	 * Constraint:
	 *     newName=ID
	 * </pre>
	 */
	protected void sequence_MappingMode(ISerializationContext context, MappingMode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.MAPPING_MODE__NEW_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.MAPPING_MODE__NEW_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingModeAccess().getNewNameIDTerminalRuleCall_1_1_0(), semanticObject.getNewName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MappingRule returns MappingRule
	 *
	 * Constraint:
	 *     ((from=STRING to=STRING) | (pattern=Pattern to=STRING))
	 * </pre>
	 */
	protected void sequence_MappingRule(ISerializationContext context, MappingRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MappingRules returns MappingRules
	 *
	 * Constraint:
	 *     (rules+=MappingRule rules+=MappingRule*)
	 * </pre>
	 */
	protected void sequence_MappingRules(ISerializationContext context, MappingRules semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MathExpression returns Primary
	 *
	 * Constraint:
	 *     ((operand=Operand | expression=MathExpression | call=FunctionCall) (operator=Operator right=Primary)*)
	 * </pre>
	 */
	protected void sequence_MathExpression_Primary(ISerializationContext context, Primary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns MathOp
	 *     MathOp returns MathOp
	 *
	 * Constraint:
	 *     (expression=MathExpression newName=ID)
	 * </pre>
	 */
	protected void sequence_MathOp(ISerializationContext context, MathOp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.MATH_OP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.MATH_OP__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.MATH_OP__NEW_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.MATH_OP__NEW_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathOpAccess().getExpressionMathExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getMathOpAccess().getNewNameIDTerminalRuleCall_5_0(), semanticObject.getNewName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FilterCondition returns MissingFilter
	 *     MissingFilter returns MissingFilter
	 *
	 * Constraint:
	 *     (columns=ColumnList includeExclude=IncludeExclude)
	 * </pre>
	 */
	protected void sequence_MissingFilter(ISerializationContext context, MissingFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.MISSING_FILTER__COLUMNS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.MISSING_FILTER__COLUMNS));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.FILTER_CONDITION__INCLUDE_EXCLUDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.FILTER_CONDITION__INCLUDE_EXCLUDE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMissingFilterAccess().getColumnsColumnListParserRuleCall_2_0(), semanticObject.getColumns());
		feeder.accept(grammarAccess.getMissingFilterAccess().getIncludeExcludeIncludeExcludeParserRuleCall_4_0(), semanticObject.getIncludeExclude());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operand returns Operand
	 *
	 * Constraint:
	 *     (column=Column | number=Number | string=STRING)
	 * </pre>
	 */
	protected void sequence_Operand(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OutlierOptions returns OutlierOptions
	 *
	 * Constraint:
	 *     scope=OutlierScope
	 * </pre>
	 */
	protected void sequence_OutlierOptions(ISerializationContext context, OutlierOptions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.OUTLIER_OPTIONS__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.OUTLIER_OPTIONS__SCOPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutlierOptionsAccess().getScopeOutlierScopeParserRuleCall_2_0(), semanticObject.getScope());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OutlierStrategy returns OutlierStrategy
	 *
	 * Constraint:
	 *     (replacement=ReplacementStrategy method=DetectionMethod options=OutlierOptions?)
	 * </pre>
	 */
	protected void sequence_OutlierStrategy(ISerializationContext context, OutlierStrategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns OutlierTreatment
	 *     OutlierTreatment returns OutlierTreatment
	 *
	 * Constraint:
	 *     (columns=ColumnList strategy=OutlierStrategy)
	 * </pre>
	 */
	protected void sequence_OutlierTreatment(ISerializationContext context, OutlierTreatment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.OUTLIER_TREATMENT__COLUMNS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.OUTLIER_TREATMENT__COLUMNS));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.OUTLIER_TREATMENT__STRATEGY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.OUTLIER_TREATMENT__STRATEGY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutlierTreatmentAccess().getColumnsColumnListParserRuleCall_2_0(), semanticObject.getColumns());
		feeder.accept(grammarAccess.getOutlierTreatmentAccess().getStrategyOutlierStrategyParserRuleCall_5_0(), semanticObject.getStrategy());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (value=STRING | regex=Regex)
	 * </pre>
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DetectionMethod returns PercentileMethod
	 *     PercentileMethod returns PercentileMethod
	 *
	 * Constraint:
	 *     (lower=Number upper=Number)
	 * </pre>
	 */
	protected void sequence_PercentileMethod(ISerializationContext context, PercentileMethod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.PERCENTILE_METHOD__LOWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.PERCENTILE_METHOD__LOWER));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.PERCENTILE_METHOD__UPPER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.PERCENTILE_METHOD__UPPER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPercentileMethodAccess().getLowerNumberParserRuleCall_3_0(), semanticObject.getLower());
		feeder.accept(grammarAccess.getPercentileMethodAccess().getUpperNumberParserRuleCall_6_0(), semanticObject.getUpper());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Contract returns Postcondition
	 *     Postcondition returns Postcondition
	 *
	 * Constraint:
	 *     (name=ContractName body=ContractBody)
	 * </pre>
	 */
	protected void sequence_Postcondition(ISerializationContext context, Postcondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostconditionAccess().getNameContractNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPostconditionAccess().getBodyContractBodyParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Contract returns Precondition
	 *     Precondition returns Precondition
	 *
	 * Constraint:
	 *     (name=ContractName body=ContractBody)
	 * </pre>
	 */
	protected void sequence_Precondition(ISerializationContext context, Precondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.CONTRACT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreconditionAccess().getNameContractNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPreconditionAccess().getBodyContractBodyParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary returns Primary
	 *
	 * Constraint:
	 *     (operand=Operand | expression=MathExpression | call=FunctionCall)
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, Primary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RangeBounds returns RangeBounds
	 *
	 * Constraint:
	 *     ((lower=BoundValue upper=BoundValue) | (lower=BoundValue upper=BoundValue) | (lower=BoundValue upper=BoundValue) | (lower=BoundValue upper=BoundValue))
	 * </pre>
	 */
	protected void sequence_RangeBounds(ISerializationContext context, RangeBounds semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FilterCondition returns RangeFilter
	 *     RangeFilter returns RangeFilter
	 *
	 * Constraint:
	 *     (column=Column bounds=RangeBounds includeExclude=IncludeExclude)
	 * </pre>
	 */
	protected void sequence_RangeFilter(ISerializationContext context, RangeFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.RANGE_FILTER__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.RANGE_FILTER__COLUMN));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.RANGE_FILTER__BOUNDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.RANGE_FILTER__BOUNDS));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.FILTER_CONDITION__INCLUDE_EXCLUDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.FILTER_CONDITION__INCLUDE_EXCLUDE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeFilterAccess().getColumnColumnParserRuleCall_2_0(), semanticObject.getColumn());
		feeder.accept(grammarAccess.getRangeFilterAccess().getBoundsRangeBoundsParserRuleCall_4_0(), semanticObject.getBounds());
		feeder.accept(grammarAccess.getRangeFilterAccess().getIncludeExcludeIncludeExcludeParserRuleCall_6_0(), semanticObject.getIncludeExclude());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Regex returns Regex
	 *
	 * Constraint:
	 *     (pattern=STRING flags=STRING?)
	 * </pre>
	 */
	protected void sequence_Regex(ISerializationContext context, Regex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReplacementStrategy returns ReplacementStrategy
	 *
	 * Constraint:
	 *     value=Number
	 * </pre>
	 */
	protected void sequence_ReplacementStrategy(ISerializationContext context, ReplacementStrategy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.REPLACEMENT_STRATEGY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.REPLACEMENT_STRATEGY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReplacementStrategyAccess().getValueNumberParserRuleCall_3_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns RowFilter
	 *     RowFilter returns RowFilter
	 *
	 * Constraint:
	 *     condition=FilterCondition
	 * </pre>
	 */
	protected void sequence_RowFilter(ISerializationContext context, RowFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.ROW_FILTER__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.ROW_FILTER__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRowFilterAccess().getConditionFilterConditionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractType returns SpecialValueContract
	 *     SpecialValueContract returns SpecialValueContract
	 *
	 * Constraint:
	 *     (field=ContractField | field=ContractField)
	 * </pre>
	 */
	protected void sequence_SpecialValueContract(ISerializationContext context, SpecialValueContract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns Step
	 *
	 * Constraint:
	 *     (name=ID transformation=Transformation target=ID? contracts=ContractBlock?)
	 * </pre>
	 */
	protected void sequence_Step(ISerializationContext context, Step semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FilterCondition returns StringFilter
	 *     StringFilter returns StringFilter
	 *
	 * Constraint:
	 *     ((column=Column pattern=Pattern includeExclude=IncludeExclude) | (column=Column pattern=Pattern includeExclude=IncludeExclude))
	 * </pre>
	 */
	protected void sequence_StringFilter(ISerializationContext context, StringFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns SubstringMapping
	 *     Mapping returns SubstringMapping
	 *     SubstringMapping returns SubstringMapping
	 *
	 * Constraint:
	 *     (column=Column from=STRING to=STRING mode=MappingMode)
	 * </pre>
	 */
	protected void sequence_SubstringMapping(ISerializationContext context, SubstringMapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.MAPPING__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.MAPPING__COLUMN));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.SUBSTRING_MAPPING__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.SUBSTRING_MAPPING__FROM));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.SUBSTRING_MAPPING__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.SUBSTRING_MAPPING__TO));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.MAPPING__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.MAPPING__MODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubstringMappingAccess().getColumnColumnParserRuleCall_2_0(), semanticObject.getColumn());
		feeder.accept(grammarAccess.getSubstringMappingAccess().getFromSTRINGTerminalRuleCall_4_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getSubstringMappingAccess().getToSTRINGTerminalRuleCall_6_0(), semanticObject.getTo());
		feeder.accept(grammarAccess.getSubstringMappingAccess().getModeMappingModeParserRuleCall_8_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ThenClause returns ThenClause
	 *
	 * Constraint:
	 *     (field=ContractField op=BelongOp result=DataResult)
	 * </pre>
	 */
	protected void sequence_ThenClause(ISerializationContext context, ThenClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.THEN_CLAUSE__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.THEN_CLAUSE__FIELD));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.THEN_CLAUSE__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.THEN_CLAUSE__OP));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.THEN_CLAUSE__RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.THEN_CLAUSE__RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThenClauseAccess().getFieldContractFieldParserRuleCall_1_0(), semanticObject.getField());
		feeder.accept(grammarAccess.getThenClauseAccess().getOpBelongOpParserRuleCall_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getThenClauseAccess().getResultDataResultParserRuleCall_3_0(), semanticObject.getResult());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns TypeConversion
	 *     TypeConversion returns TypeConversion
	 *
	 * Constraint:
	 *     (
	 *         (columns=ColumnList separator=DecimalSeparator?) | 
	 *         columns=ColumnList | 
	 *         columns=ColumnList | 
	 *         columns=ColumnList | 
	 *         (columns=ColumnList format=DateFormat?)
	 *     )
	 * </pre>
	 */
	protected void sequence_TypeConversion(ISerializationContext context, TypeConversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataCondition returns ValueCheck
	 *     ValueCheck returns ValueCheck
	 *     DataResult returns ValueCheck
	 *
	 * Constraint:
	 *     value=Value
	 * </pre>
	 */
	protected void sequence_ValueCheck(ISerializationContext context, ValueCheck semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.VALUE_CHECK__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.VALUE_CHECK__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueCheckAccess().getValueValueParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueList returns ValueList
	 *
	 * Constraint:
	 *     (value=Value | (values+=Value values+=Value*))
	 * </pre>
	 */
	protected void sequence_ValueList(ISerializationContext context, ValueList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns ValueMapping
	 *     Mapping returns ValueMapping
	 *     ValueMapping returns ValueMapping
	 *
	 * Constraint:
	 *     (column=Column rules=MappingRules mode=MappingMode)
	 * </pre>
	 */
	protected void sequence_ValueMapping(ISerializationContext context, ValueMapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.MAPPING__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.MAPPING__COLUMN));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.VALUE_MAPPING__RULES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.VALUE_MAPPING__RULES));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.MAPPING__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.MAPPING__MODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueMappingAccess().getColumnColumnParserRuleCall_2_0(), semanticObject.getColumn());
		feeder.accept(grammarAccess.getValueMappingAccess().getRulesMappingRulesParserRuleCall_5_0(), semanticObject.getRules());
		feeder.accept(grammarAccess.getValueMappingAccess().getModeMappingModeParserRuleCall_7_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractType returns ValueRangeContract
	 *     ValueRangeContract returns ValueRangeContract
	 *
	 * Constraint:
	 *     (field=ContractField value=ContractValue)
	 * </pre>
	 */
	protected void sequence_ValueRangeContract(ISerializationContext context, ValueRangeContract semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.VALUE_RANGE_CONTRACT__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.VALUE_RANGE_CONTRACT__FIELD));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.VALUE_RANGE_CONTRACT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.VALUE_RANGE_CONTRACT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueRangeContractAccess().getFieldContractFieldParserRuleCall_2_0(), semanticObject.getField());
		feeder.accept(grammarAccess.getValueRangeContractAccess().getValueContractValueParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (number=Number | string=STRING)
	 * </pre>
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowBody returns WorkflowBody
	 *
	 * Constraint:
	 *     steps+=Step+
	 * </pre>
	 */
	protected void sequence_WorkflowBody(ISerializationContext context, WorkflowBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (name=STRING source=DataSource body=WorkflowBody)
	 * </pre>
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.WORKFLOW__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.WORKFLOW__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.WORKFLOW__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.WORKFLOW__SOURCE));
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.WORKFLOW__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.WORKFLOW__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkflowAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getWorkflowAccess().getSourceDataSourceParserRuleCall_3_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getWorkflowAccess().getBodyWorkflowBodyParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DetectionMethod returns ZScoreMethod
	 *     ZScoreMethod returns ZScoreMethod
	 *
	 * Constraint:
	 *     threshold=Number
	 * </pre>
	 */
	protected void sequence_ZScoreMethod(ISerializationContext context, ZScoreMethod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDSLPackage.Literals.ZSCORE_METHOD__THRESHOLD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDSLPackage.Literals.ZSCORE_METHOD__THRESHOLD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getZScoreMethodAccess().getThresholdNumberParserRuleCall_1_2_0(), semanticObject.getThreshold());
		feeder.finish();
	}
	
	
}
