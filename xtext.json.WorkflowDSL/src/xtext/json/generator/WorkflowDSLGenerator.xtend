/*
 * Generated by Xtext 2.40.0
 * Modified to generate KNIME-style node-based JSON format
 */
package xtext.json.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import xtext.json.workflowDSL.*
import java.util.HashMap
import java.util.ArrayList

/**
 * Generates JSON representation from WorkflowDSL files in KNIME node format.
 */
class WorkflowDSLGenerator extends AbstractGenerator {

	// Node ID counter - starts from 1
	var int nodeIdCounter = 1
	
	// Map to store step names to node IDs
	val stepToNodeId = new HashMap<String, Integer>()
	
	// Map to store original node IDs for metanodes
	val originalNodeIds = new HashMap<String, Integer>()

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (workflow : resource.allContents.filter(Workflow).toIterable) {
			val fileName = workflow.name?.replaceAll('"', '') ?: "workflow"
			fsa.generateFile(fileName + ".json", workflow.toJson)
		}
	}
	
	def String toJson(Workflow workflow) {
		// Reset counters for each workflow
		nodeIdCounter = 1
		stepToNodeId.clear()
		originalNodeIds.clear()
		
		val sb = new StringBuilder
		sb.append("{\n")
		
		// Generate nodes section
		sb.append("    \"nodes\": [\n")
		val nodes = collectNodes(workflow)
		for (var i = 0; i < nodes.size; i++) {
			sb.append(nodes.get(i))
			if (i < nodes.size - 1) {
				sb.append(",\n")
			} else {
				sb.append("\n")
			}
		}
		sb.append("    ],\n")
		
		// Generate connections section
		sb.append("    \"connections\": [\n")
		val connections = collectConnections(workflow)
		for (var i = 0; i < connections.size; i++) {
			sb.append(connections.get(i))
			if (i < connections.size - 1) {
				sb.append(",\n")
			} else {
				sb.append("\n")
			}
		}
		sb.append("    ],\n")
		
		// Generate contracts section
		sb.append("    \"contracts\": ")
		sb.append(generateContracts(workflow))
		sb.append("\n")
		
		sb.append("}")
		return sb.toString
	}
	
	def ArrayList<String> collectNodes(Workflow workflow) {
		val nodes = new ArrayList<String>()
		
		// Add data source node
		val sourceId = getNextNodeId()
		stepToNodeId.put("data", sourceId)
		nodes.add(generateDataSourceNode(workflow.source, sourceId))
		
		// Process all steps
		for (step : workflow.body.steps) {
			val stepNodes = generateStepNodes(step)
			nodes.addAll(stepNodes)
		}
		
		return nodes
	}
	
	def ArrayList<String> collectConnections(Workflow workflow) {
		val connections = new ArrayList<String>()
		
		// Generate connections based on step targets
		for (step : workflow.body.steps) {
			if (step.target !== null) {
				val sourceId = stepToNodeId.get(step.target)
				val destId = stepToNodeId.get(step.name)
				
				if (sourceId !== null && destId !== null) {
					connections.add(generateConnection(sourceId, destId))
				}
			}
		}
		
		return connections
	}
	
	def String generateDataSourceNode(DataSource source, int id) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"id\": ").append(id).append(",\n")
		sb.append("            \"node_name\": \"File Reader\",\n")
		sb.append("            \"node_type\": \"org.knime.base.node.io.filehandling.csv.reader.FileReaderNodeFactory\",\n")
		sb.append("            \"parameters\": {\n")
		
		if (source.reader instanceof CSVReader) {
			val csvReader = source.reader as CSVReader
			sb.append("                \"file_path\": \"").append(csvReader.filePath.path.replaceAll('"', '')).append("\"\n")
		}
		
		sb.append("            }\n")
		sb.append("        }")
		return sb.toString
	}
	
	def ArrayList<String> generateStepNodes(Step step) {
		val nodes = new ArrayList<String>()
		
		// Assign ID to this step
		val stepId = getNextNodeId()
		stepToNodeId.put(step.name, stepId)
		
		val nodeJson = generateNodeFromTransformation(step, stepId)
		nodes.add(nodeJson)
		
		return nodes
	}
	
	def String generateNodeFromTransformation(Step step, int id) {
		val transformation = step.transformation
		
		switch transformation {
			Imputation: generateImputationNode(step, id, transformation)
			RowFilter: generateRowFilterNode(step, id, transformation)
			ColumnFilter: generateColumnFilterNode(step, id, transformation)
			Mapping: generateMappingNode(step, id, transformation)
			TypeConversion: generateTypeConversionNode(step, id, transformation)
			OutlierTreatment: generateOutlierNode(step, id, transformation)
			Binner: generateBinnerNode(step, id, transformation)
			default: generateGenericNode(step, id)
		}
	}
	
	def String generateImputationNode(Step step, int id, Imputation imputation) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"id\": ").append(id).append(",\n")
		sb.append("            \"node_name\": \"Missing Value\",\n")
		sb.append("            \"parameters\": {\n")
		
		// Extract columns
		val columns = extractColumnsFromImputation(imputation)
		
		// Generate in_columns as array of objects
		sb.append("                \"in_columns\": [")
		if (!columns.empty) {
			sb.append("\n")
			for (var i = 0; i < columns.size; i++) {
				sb.append("                    {\n")
				sb.append("                        \"column_name\": \"").append(columns.get(i)).append("\",\n")
				sb.append("                        \"column_type\": \"xstring\"\n")
				sb.append("                    }")
				if (i < columns.size - 1) sb.append(",")
				sb.append("\n")
			}
			sb.append("                ")
		}
		sb.append("],\n")
		
		// Generate out_columns as array of objects
		sb.append("                \"out_columns\": [")
		if (!columns.empty) {
			sb.append("\n")
			for (var i = 0; i < columns.size; i++) {
				sb.append("                    {\n")
				sb.append("                        \"column_name\": \"").append(columns.get(i)).append("\",\n")
				sb.append("                        \"column_type\": \"xstring\"\n")
				sb.append("                    }")
				if (i < columns.size - 1) sb.append(",")
				sb.append("\n")
			}
			sb.append("                ")
		}
		sb.append("],\n")
		
		// Determine imputation type
		val method = imputation.method
		if (method instanceof TransformImpute) {
			val transformMethod = method as TransformImpute
			val imputationType = getImputationType(transformMethod)
			sb.append("                \"imputationType\": \"").append(imputationType).append("\",\n")
			
			// Add fixStringValues for fixed value imputation
			if (transformMethod.replacementValue !== null) {
				sb.append("                \"fixStringValues\": [\n")
				for (var i = 0; i < columns.size; i++) {
					sb.append("                    ").append(formatValue(transformMethod.replacementValue))
					if (i < columns.size - 1) sb.append(",")
					sb.append("\n")
				}
				sb.append("                ]")
			} else {
				sb.append("                \"fixStringValues\": [\n")
				for (var i = 0; i < columns.size; i++) {
					sb.append("                    null")
					if (i < columns.size - 1) sb.append(",")
					sb.append("\n")
				}
				sb.append("                ]")
			}
		}
		
		// Check if this is a metanode (has original_node_id)
		if (originalNodeIds.containsKey(step.name)) {
			sb.append(",\n")
			sb.append("                \"original_node_id\": ").append(originalNodeIds.get(step.name))
		}
		
		sb.append("\n")
		sb.append("            }\n")
		sb.append("        }")
		return sb.toString
	}
	
	def ArrayList<String> extractColumnsFromImputation(Imputation imputation) {
		val columns = new ArrayList<String>()
		if (imputation.columns !== null && imputation.columns.columns !== null) {
			for (column : imputation.columns.columns) {
				val colName = if (column.column !== null) column.column else column.name
				if (colName !== null) {
					columns.add(colName)
				}
			}
		}
		return columns
	}
	
	def String getImputationType(TransformImpute transform) {
		val nodeText = org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode(transform)?.text ?: ""
		
		if (nodeText.contains("most_frequent")) return "MostFrequent"
		if (nodeText.contains("mean")) return "Mean"
		if (nodeText.contains("median")) return "Median"
		if (nodeText.contains("interpolation")) return "Interpolation"
		if (nodeText.contains("previous_value")) return "PreviousValue"
		if (nodeText.contains("next_value")) return "NextValue"
		if (nodeText.contains("fixed")) return "Fixed Value"
		
		return "MostFrequent"
	}
	
	def String generateRowFilterNode(Step step, int id, RowFilter filter) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"id\": ").append(id).append(",\n")
		sb.append("            \"node_name\": \"Row Filter (deprecated)\",\n")
		sb.append("            \"node_type\": \"org.knime.base.node.preproc.filter.row.RowFilterNodeFactory\",\n")
		sb.append("            \"parameters\": {\n")
		sb.append("                \"filter_type\": \"RangeVal_RowFilter\",\n")
		
		if (filter.condition instanceof RangeFilter) {
			val rangeFilter = filter.condition as RangeFilter
			val bounds = rangeFilter.bounds
			
			// Add null checks for bounds and its fields
			if (bounds !== null) {
				sb.append("                \"lower_bound\": ").append(formatBoundValue(bounds.lower)).append(",\n")
				sb.append("                \"upper_bound\": ").append(formatBoundValue(bounds.upper)).append(",\n")
				sb.append("                \"has_lower_bound\": ").append(!isInfinity(bounds.lower)).append(",\n")
				sb.append("                \"has_upper_bound\": ").append(!isInfinity(bounds.upper)).append(",\n")
			} else {
				// Default values if bounds is null
				sb.append("                \"lower_bound\": 0.0,\n")
				sb.append("                \"upper_bound\": 1000000000,\n")
				sb.append("                \"has_lower_bound\": false,\n")
				sb.append("                \"has_upper_bound\": false,\n")
			}
			
			val inclusion = if (rangeFilter.includeExclude == "include") "INCLUDE" else "EXCLUDE"
			sb.append("                \"filter_type_inclusion\": \"").append(inclusion).append("\",\n")
			
			// Extract column from range filter
			sb.append("                \"in_columns\": [")
			if (rangeFilter.column !== null) {
				val colName = if (rangeFilter.column.column !== null) rangeFilter.column.column else rangeFilter.column.name
				sb.append("\n                    {\n")
				sb.append("                        \"column_name\": \"").append(colName).append("\",\n")
				sb.append("                        \"column_type\": \"xstring\"\n")
				sb.append("                    }\n                ")
			}
			sb.append("],\n")
			
			sb.append("                \"out_columns\": [")
			if (rangeFilter.column !== null) {
				val colName = if (rangeFilter.column.column !== null) rangeFilter.column.column else rangeFilter.column.name
				sb.append("\n                    {\n")
				sb.append("                        \"column_name\": \"").append(colName).append("\",\n")
				sb.append("                        \"column_type\": \"xstring\"\n")
				sb.append("                    }\n                ")
			}
			sb.append("]\n")
		}
		
		sb.append("            }\n")
		sb.append("        }")
		return sb.toString
	}
	
	def String generateColumnFilterNode(Step step, int id, ColumnFilter filter) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"id\": ").append(id).append(",\n")
		sb.append("            \"node_name\": \"Column Filter\",\n")
		sb.append("            \"node_type\": \"org.knime.base.node.preproc.filter.column.DataColumnSpecFilterNodeFactory\",\n")
		sb.append("            \"parameters\": {\n")
		
		// Extract columns from ColumnFilter
		val columns = new ArrayList<String>()
		if (filter.columns !== null && filter.columns.columns !== null) {
			for (column : filter.columns.columns) {
				val colName = if (column.column !== null) column.column else column.name
				if (colName !== null) {
					columns.add(colName)
				}
			}
		}
		
		// Generate in_columns as empty (ColumnFilter doesn't show in_columns in target)
		sb.append("                \"in_columns\": [],\n")
		
		// Generate out_columns with extracted columns
		sb.append("                \"out_columns\": [")
		if (!columns.empty) {
			sb.append("\n")
			for (var i = 0; i < columns.size; i++) {
				sb.append("                    {\n")
				sb.append("                        \"column_name\": \"").append(columns.get(i)).append("\",\n")
				sb.append("                        \"column_type\": \"xstring\"\n")
				sb.append("                    }")
				if (i < columns.size - 1) sb.append(",")
				sb.append("\n")
			}
			sb.append("                ")
		}
		sb.append("]\n")
		
		sb.append("            }\n")
		sb.append("        }")
		return sb.toString
	}
	
	def String generateMappingNode(Step step, int id, Mapping mapping) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"id\": ").append(id).append(",\n")
		sb.append("            \"node_name\": \"Rule Engine\",\n")
		sb.append("            \"node_type\": \"org.knime.base.node.rules.engine.RuleEngineNodeFactory\",\n")
		sb.append("            \"parameters\": {\n")
		
		if (mapping instanceof ValueMapping) {
			val valueMapping = mapping as ValueMapping
			val column = valueMapping.column.name
			
			// Generate rules
			sb.append("                \"rules\": [\n")
			val rules = valueMapping.rules.rules
			for (var i = 0; i < rules.size; i++) {
				val rule = rules.get(i)
				sb.append("                    \"$").append(column).append("$ LIKE \\\"*")
				sb.append(rule.from.replaceAll('"', '')).append("*\\\" => \\\"")
				sb.append(rule.to.replaceAll('"', '')).append("\\\"\"")
				if (i < rules.size - 1) sb.append(",\n") else sb.append(",\n")
			}
			sb.append("                    \"TRUE => $").append(column).append("$\"\n")
			sb.append("                ],\n")
			
			// Generate function_types
			sb.append("                \"function_types\": [\n")
			for (var i = 0; i < rules.size; i++) {
				sb.append("                    \"LIKE\"")
				if (i < rules.size - 1) sb.append(",\n") else sb.append("\n")
			}
			sb.append("                ],\n")
			
			// Add mapping metadata
			val newName = if (valueMapping.mode.newName !== null) valueMapping.mode.newName else column
			sb.append("                \"new_column_name\": \"prediction\",\n")
			sb.append("                \"replace_column_name\": \"").append(column).append("\",\n")
			sb.append("                \"append_column\": false,\n")
			
			// Add in_columns
			sb.append("                \"in_columns\": [\n")
			sb.append("                    {\n")
			sb.append("                        \"column_name\": \"").append(column).append("\",\n")
			sb.append("                        \"column_type\": \"xstring\"\n")
			sb.append("                    }\n")
			sb.append("                ],\n")
			
			// Add out_columns
			sb.append("                \"out_columns\": [\n")
			sb.append("                    {\n")
			sb.append("                        \"column_name\": \"prediction\",\n")
			sb.append("                        \"column_type\": \"xstring\"\n")
			sb.append("                    }\n")
			sb.append("                ],\n")
			
			// Generate mapping object
			sb.append("                \"mapping\": {\n")
			sb.append("                    \"replace_column_name\": \"").append(column).append("\",\n")
			sb.append("                    \"mapping_parameters\": [\n")
			for (var i = 0; i < rules.size; i++) {
				val rule = rules.get(i)
				sb.append("                        {\n")
				sb.append("                            \"key\": \"").append(rule.from.replaceAll('"', '')).append("\",\n")
				sb.append("                            \"value\": \"").append(rule.to.replaceAll('"', '')).append("\"\n")
				sb.append("                        }")
				if (i < rules.size - 1) sb.append(",\n") else sb.append("\n")
			}
			sb.append("                    ],\n")
			sb.append("                    \"map_operation\": \"VALUE_MAPPING\",\n")
			sb.append("                    \"unique_replacement_one_column\": false\n")
			sb.append("                }\n")
		}
		
		sb.append("            }\n")
		sb.append("        }")
		return sb.toString
	}
	
	def String generateTypeConversionNode(Step step, int id, TypeConversion conversion) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"id\": ").append(id).append(",\n")
		sb.append("            \"node_name\": \"String to Number\",\n")
		sb.append("            \"node_type\": \"org.knime.base.node.preproc.colconvert.stringtonumber2.StringToNumber2NodeFactory\",\n")
		sb.append("            \"parameters\": {\n")
		sb.append("                \"decimal_separator\": \".\",\n")
		
		// Extract columns
		sb.append("                \"in_columns\": [")
		if (conversion.columns !== null && conversion.columns.columns !== null) {
			var isFirst = true
			for (column : conversion.columns.columns) {
				if (!isFirst) sb.append(",")
				isFirst = false
				val colName = if (column.column !== null) column.column else column.name
				sb.append("\n                    {\n")
				sb.append("                        \"column_name\": \"").append(colName).append("\",\n")
				sb.append("                        \"column_type\": \"xstring\"\n")
				sb.append("                    }")
			}
			if (!isFirst) sb.append("\n                ")
		}
		sb.append("],\n")
		
		sb.append("                \"out_columns\": [")
		if (conversion.columns !== null && conversion.columns.columns !== null) {
			var isFirst = true
			for (column : conversion.columns.columns) {
				if (!isFirst) sb.append(",")
				isFirst = false
				val colName = if (column.column !== null) column.column else column.name
				sb.append("\n                    {\n")
				sb.append("                        \"column_name\": \"").append(colName).append("\",\n")
				sb.append("                        \"column_type\": \"xstring\"\n")
				sb.append("                    }")
			}
			if (!isFirst) sb.append("\n                ")
		}
		sb.append("]\n")
		
		sb.append("            }\n")
		sb.append("        }")
		return sb.toString
	}
	
	def String generateOutlierNode(Step step, int id, OutlierTreatment outlier) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"id\": ").append(id).append(",\n")
		sb.append("            \"node_name\": \"Numeric Outliers\",\n")
		sb.append("            \"node_type\": \"org.knime.base.node.stats.outlier.handler.NumericOutliersNodeFactory\",\n")
		sb.append("            \"parameters\": {\n")
		
		// Extract columns
		sb.append("                \"in_columns\": [")
		if (outlier.columns !== null && outlier.columns.columns !== null) {
			var isFirst = true
			for (column : outlier.columns.columns) {
				if (!isFirst) sb.append(",")
				isFirst = false
				val colName = if (column.column !== null) column.column else column.name
				sb.append("\n                    {\n")
				sb.append("                        \"column_name\": \"").append(colName).append("\",\n")
				sb.append("                        \"column_type\": \"xstring\"\n")
				sb.append("                    }")
			}
			if (!isFirst) sb.append("\n                ")
		}
		sb.append("],\n")
		
		sb.append("                \"out_columns\": [")
		if (outlier.columns !== null && outlier.columns.columns !== null) {
			var isFirst = true
			for (column : outlier.columns.columns) {
				if (!isFirst) sb.append(",")
				isFirst = false
				val colName = if (column.column !== null) column.column else column.name
				sb.append("\n                    {\n")
				sb.append("                        \"column_name\": \"").append(colName).append("\",\n")
				sb.append("                        \"column_type\": \"xstring\"\n")
				sb.append("                    }")
			}
			if (!isFirst) sb.append("\n                ")
		}
		sb.append("],\n")
		
		sb.append("                \"estimation_type\": \"R_4\",\n")
		sb.append("                \"iqr_scalar\": 1.5,\n")
		sb.append("                \"replacement_strategy\": \"Closest permitted value\",\n")
		sb.append("                \"outlier_treatment\": \"Replace outlier values\",\n")
		sb.append("                \"detection_option\": \"All outliers\"\n")
		sb.append("            }\n")
		sb.append("        }")
		return sb.toString
	}
	
	def String generateBinnerNode(Step step, int id, Binner binner) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"id\": ").append(id).append(",\n")
		sb.append("            \"node_name\": \"Numeric Binner\",\n")
		sb.append("            \"node_type\": \"org.knime.base.node.preproc.binner.BinnerNodeFactory\",\n")
		sb.append("            \"parameters\": {\n")
		
		// Generate bins
		sb.append("                \"bins\": [\n")
		val bins = binner.definitions.definitions
		for (var i = 0; i < bins.size; i++) {
			val bin = bins.get(i)
			sb.append("                    {\n")
			sb.append("                        \"binName\": \"").append(bin.name.name.replaceAll('"', '')).append("\",\n")
			sb.append("                        \"closureType\": \"").append(getClosureType(bin.interval)).append("\",\n")
			sb.append("                        \"leftMargin\": \"").append(formatIntervalBound(bin.interval.lower)).append("\",\n")
			sb.append("                        \"rightMargin\": \"").append(formatIntervalBound(bin.interval.upper)).append("\"\n")
			sb.append("                    }")
			if (i < bins.size - 1) sb.append(",\n") else sb.append("\n")
		}
		sb.append("                ],\n")
		
		// Extract column information
		val inputColumn = if (binner.column.column !== null) binner.column.column else binner.column.name
		val outputColumn = if (binner.mode.newName !== null) binner.mode.newName else (inputColumn + "_binned")
		
		sb.append("                \"in_columns\": [\n")
		sb.append("                    {\n")
		sb.append("                        \"column_name\": \"").append(inputColumn).append("\",\n")
		sb.append("                        \"column_type\": \"xstring\"\n")
		sb.append("                    }\n")
		sb.append("                ],\n")
		
		sb.append("                \"out_columns\": [\n")
		sb.append("                    {\n")
		sb.append("                        \"column_name\": \"").append(outputColumn).append("\",\n")
		sb.append("                        \"column_type\": \"xstring\"\n")
		sb.append("                    }\n")
		sb.append("                ]")
		
		// Check if this is a metanode
		if (originalNodeIds.containsKey(step.name)) {
			sb.append(",\n")
			sb.append("                \"original_node_id\": ").append(originalNodeIds.get(step.name))
		}
		
		sb.append("\n")
		sb.append("            }\n")
		sb.append("        }")
		return sb.toString
	}
	
	def String generateGenericNode(Step step, int id) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"id\": ").append(id).append(",\n")
		sb.append("            \"node_name\": \"").append(step.name).append("\",\n")
		sb.append("            \"parameters\": {}\n")
		sb.append("        }")
		return sb.toString
	}
	
	def String generateConnection(int sourceId, int destId) {
		val sb = new StringBuilder
		sb.append("        {\n")
		sb.append("            \"sourceID\": ").append(sourceId).append(",\n")
		sb.append("            \"destID\": ").append(destId).append("\n")
		sb.append("        }")
		return sb.toString
	}
	
	def String generateContracts(Workflow workflow) {
		val sb = new StringBuilder
		sb.append("{\n")
		
		val contractSteps = workflow.body.steps.filter[contracts !== null]
		var isFirst = true
		
		for (step : contractSteps) {
			val nodeId = stepToNodeId.get(step.name)
			if (nodeId !== null && step.contracts !== null) {
				if (!isFirst) sb.append(",\n")
				isFirst = false
				
				sb.append("        \"").append(nodeId).append("\": ")
				sb.append(generateStepContracts(step))
			}
		}
		
		sb.append("\n    }")
		return sb.toString
	}
	
	def String generateStepContracts(Step step) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append("            \"columns\": {\n")
		
		// Extract column-specific contracts
		val columnContracts = extractColumnContracts(step.contracts)
		var isFirst = true
		
		for (entry : columnContracts.entrySet) {
			if (!isFirst) sb.append(",\n")
			isFirst = false
			
			sb.append("                \"").append(entry.key).append("\": ")
			sb.append(entry.value)
		}
		
		sb.append("\n            }\n")
		sb.append("        }")
		return sb.toString
	}
	
	def HashMap<String, String> extractColumnContracts(ContractBlock contractBlock) {
		val result = new HashMap<String, String>()
		
		// Group contracts by column
		val contractsByColumn = new HashMap<String, ArrayList<Contract>>()
		
		for (contract : contractBlock.contracts) {
			// Check if this is a FieldRangeContract with multiple columns
			if (contract.body?.type instanceof FieldRangeContract) {
				val fieldRangeContract = contract.body.type as FieldRangeContract
				val columnList = fieldRangeContract.columns
				
				// Add this contract to ALL columns in the list
				if (columnList !== null && columnList.columns !== null) {
					for (column : columnList.columns) {
						val colName = if (column.column !== null) column.column else column.name
						if (colName !== null) {
							if (!contractsByColumn.containsKey(colName)) {
								contractsByColumn.put(colName, new ArrayList<Contract>())
							}
							contractsByColumn.get(colName).add(contract)
						}
					}
				}
			} else if (contract.body?.type instanceof ConditionContract) {
				// Check if condition contains FieldRangeContract
				val conditionContract = contract.body.type as ConditionContract
				val ifClause = conditionContract.ifClause
				
				if (ifClause?.expression instanceof FieldRangeContract) {
					val fieldRangeContract = ifClause.expression as FieldRangeContract
					val columnList = fieldRangeContract.columns
					
					// Add this contract to ALL columns in the list
					if (columnList !== null && columnList.columns !== null) {
						for (column : columnList.columns) {
							val colName = if (column.column !== null) column.column else column.name
							if (colName !== null) {
								if (!contractsByColumn.containsKey(colName)) {
									contractsByColumn.put(colName, new ArrayList<Contract>())
								}
								contractsByColumn.get(colName).add(contract)
							}
						}
					}
				} else {
					// Regular condition contract with single column
					val columnName = extractColumnName(contract)
					if (columnName !== null) {
						if (!contractsByColumn.containsKey(columnName)) {
							contractsByColumn.put(columnName, new ArrayList<Contract>())
						}
						contractsByColumn.get(columnName).add(contract)
					}
				}
			} else {
				// Regular contract with single column
				val columnName = extractColumnName(contract)
				if (columnName !== null) {
					if (!contractsByColumn.containsKey(columnName)) {
						contractsByColumn.put(columnName, new ArrayList<Contract>())
					}
					contractsByColumn.get(columnName).add(contract)
				}
			}
		}
		
		// Generate JSON for each column
		for (entry : contractsByColumn.entrySet) {
			result.put(entry.key, generateColumnContractJson(entry.value))
		}
		
		return result
	}
	
	def String extractColumnName(Contract contract) {
		// Extract column name from contract body
		if (contract.body?.type !== null) {
			val contractType = contract.body.type
			
			if (contractType instanceof ValueRangeContract) {
				return contractType.field?.column?.name
			} else if (contractType instanceof SpecialValueContract) {
				return contractType.field?.column?.name
			} else if (contractType instanceof IntervalContract) {
				return contractType.field?.column?.name
			} else if (contractType instanceof CastTypeContract) {
				return contractType.field?.column?.name
			} else if (contractType instanceof FieldRangeContract) {
				// For ColumnFilter contracts, extract first column from the list
				val columnList = contractType.columns
				if (columnList !== null && columnList.columns !== null && !columnList.columns.empty) {
					val firstColumn = columnList.columns.get(0)
					return if (firstColumn.column !== null) firstColumn.column else firstColumn.name
				}
			} else if (contractType instanceof ConditionContract) {
				// For condition contracts (invariants), extract from if clause
				val ifClause = contractType.ifClause
				if (ifClause?.expression instanceof SimpleCondition) {
					val simpleCondition = ifClause.expression as SimpleCondition
					return simpleCondition.field?.column?.name
				} else if (ifClause?.expression instanceof FieldRangeContract) {
					// Handle FieldRangeContract inside condition
					val fieldRange = ifClause.expression as FieldRangeContract
					val columnList = fieldRange.columns
					if (columnList !== null && columnList.columns !== null && !columnList.columns.empty) {
						val firstColumn = columnList.columns.get(0)
						return if (firstColumn.column !== null) firstColumn.column else firstColumn.name
					}
				}
			}
		}
		
		return null
	}
	
	def String generateColumnContractJson(ArrayList<Contract> contracts) {
		val sb = new StringBuilder
		sb.append("{\n")
		
		// Separate by contract type
		val preconditions = contracts.filter[it instanceof Precondition].toList
		val postconditions = contracts.filter[it instanceof Postcondition].toList
		val invariants = contracts.filter[it instanceof Invariant].toList
		
		var hasContent = false
		
		if (!preconditions.empty) {
			sb.append("                    \"preconditions\": [\n")
			for (var i = 0; i < preconditions.size; i++) {
				sb.append(generateContractJson(preconditions.get(i), 24))
				if (i < preconditions.size - 1) sb.append(",\n") else sb.append("\n")
			}
			sb.append("                    ]")
			hasContent = true
		}
		
		if (!postconditions.empty) {
			if (hasContent) sb.append(",\n")
			sb.append("                    \"postconditions\": [\n")
			for (var i = 0; i < postconditions.size; i++) {
				sb.append(generateContractJson(postconditions.get(i), 24))
				if (i < postconditions.size - 1) sb.append(",\n") else sb.append("\n")
			}
			sb.append("                    ]")
			hasContent = true
		}
		
		if (!invariants.empty) {
			if (hasContent) sb.append(",\n")
			sb.append("                    \"invariants\": [\n")
			for (var i = 0; i < invariants.size; i++) {
				sb.append(generateContractJson(invariants.get(i), 24))
				if (i < invariants.size - 1) sb.append(",\n") else sb.append("\n")
			}
			sb.append("                    ]")
		}
		
		sb.append("\n                }")
		return sb.toString
	}
	
	def String generateContractJson(Contract contract, int indent) {
		val sb = new StringBuilder
		val spaces = " ".repeat(indent)
		
		sb.append(spaces).append("{\n")
		
		// Extract name - get the meaningful part
		val fullName = contract.name?.name ?: ""
		val contractName = extractContractNamePart(fullName)
		sb.append(spaces).append("    \"name\": \"").append(contractName).append("\",\n")
		
		// Generate contract type and details
		if (contract.body?.type !== null) {
			val typeJson = generateContractTypeJson(contract.body.type, indent + 4, contract)
			sb.append(typeJson)
		}
		
		sb.append("\n").append(spaces).append("}")
		return sb.toString
	}
	
	def String extractContractNamePart(String fullName) {
		// Extract meaningful part from contract name based on patterns
		// Example: "imputeMissingByMostFrequent(sex)_PRE_value_range" -> "value_range" (for precondition)
		// Example: "INV_StringToNumber_condition_TERRITORY" -> "condition" (for invariant)
		
		if (fullName.contains("_INVARIANT")) {
			return "condition"
		}
		
		if (fullName.contains("_INV_")) {
			val parts = fullName.split("_INV_")
			if (parts.size > 1) {
				val part = parts.get(1)
				// Extract first word after INV
				if (part.contains("_")) {
					return part.split("_").get(0)
				}
				return part
			}
		}
		
		if (fullName.contains("_PRE_")) {
			val parts = fullName.split("_PRE_")
			if (parts.size > 1) {
				return parts.get(1).replaceAll("_$", "")
			}
		}
		
		if (fullName.contains("_POST_")) {
			val parts = fullName.split("_POST_")
			if (parts.size > 1) {
				return parts.get(1).replaceAll("_$", "")
			}
		}
		
		// Fallback patterns
		if (fullName.contains("imputeMissing")) return "imputeMissing"
		if (fullName.contains("outlier")) return "outlier"
		if (fullName.contains("mapping") || fullName.contains("Mapping")) return "mapping"
		if (fullName.contains("stringToNumber") || fullName.contains("StringToNumber") || fullName.contains("castType")) return "castType"
		if (fullName.contains("specialValue")) return "specialValue"
		if (fullName.contains("binner")) return "binner"
		if (fullName.contains("rowFilter")) return "rowFilterRange"
		if (fullName.contains("columnFilter")) return "columnFilter"
		
		return fullName
	}
	
	def String generateContractTypeJson(ContractType contractType, int indent, Contract contract) {
		val spaces = " ".repeat(indent)
		val sb = new StringBuilder
		val fullName = contract.name?.name ?: ""
		
		switch contractType {
			ConditionContract: {
				// ConditionContract is ALWAYS an Invariant (100% of cases)
				// It has type "condition" with if/then structure
				if (!(contract instanceof Invariant)) {
					// This should never happen, but log error if it does
					System.err.println("WARNING: ConditionContract found in non-Invariant contract: " + fullName)
				}
				
				sb.append(spaces).append("\"type\": \"condition\",\n")
				sb.append(spaces).append("\"if\": {\n")
				sb.append(generateConditionJson(contractType.ifClause, indent + 4))
				sb.append("\n").append(spaces).append("},\n")
				sb.append(spaces).append("\"then\": {\n")
				sb.append(generateConditionJson(contractType.thenClause, indent + 4))
				sb.append("\n").append(spaces).append("}")
			}
			ValueRangeContract: {
				// ValueRangeContract is used for Preconditions and Postconditions (NEVER Invariants)
				if (contract instanceof Invariant) {
					System.err.println("WARNING: ValueRangeContract found in Invariant contract: " + fullName)
				}
				
				sb.append(spaces).append("\"type\": \"value_range\"")
				
				// Extract check value based on contract context
				var String checkValue = null
				if (contract instanceof Precondition) {
					if (fullName.contains("imputeMissing") || fullName.contains("imputeOutlier")) {
						checkValue = "has_missing"
					} else if (fullName.contains("outlier")) {
						checkValue = "numeric"
					} else if (fullName.contains("mapping") || fullName.contains("Mapping")) {
						checkValue = "value_in"
					} else if (fullName.contains("binner")) {
						checkValue = "numeric"
					} else if (fullName.contains("rowFilter")) {
						checkValue = "in_range"
					} else if (fullName.contains("columnFilter")) {
						checkValue = "exists"
					}
				} else if (contract instanceof Postcondition) {
					if (fullName.contains("imputeMissing") || fullName.contains("imputeOutlier")) {
						checkValue = "no_missing"
					} else if (fullName.contains("outlier")) {
						checkValue = "no_outliers"
					} else if (fullName.contains("mapping") || fullName.contains("Mapping")) {
						checkValue = "value_not_in"
					} else if (fullName.contains("binner")) {
						checkValue = "categorical"
					} else if (fullName.contains("rowFilter")) {
						checkValue = "in_range"
					} else if (fullName.contains("columnFilter")) {
						checkValue = "not_exists"
					}
				}
				
				if (checkValue !== null) {
					sb.append(",\n")
					sb.append(spaces).append("\"check\": \"").append(checkValue).append("\"")
				}
				
				// Add belong_op for postconditions with mapping
				if (contract instanceof Postcondition && fullName.contains("mapping")) {
					sb.append(",\n")
					sb.append(spaces).append("\"belong_op\": \"NOTBELONG\"")
				}
				
				if (contract instanceof Precondition && fullName.contains("rowFilter")) {
					sb.append(",\n")
					sb.append(spaces).append("\"belong_op\": \"BELONG\"")
				}
				
				// Extract target_type
				var String targetType = null
				if (fullName.contains("Integer") || (fullName.contains("castType") && !fullName.contains("String"))) {
					targetType = "Integer"
				} else if (fullName.contains("Double") || fullName.contains("outlier")) {
					targetType = "Double"
				} else if (fullName.contains("String") || fullName.contains("mapping")) {
					targetType = "String"
				}
				
				if (contractType.value !== null) {
					val valueType = contractType.value.type
					if (valueType !== null) {
						targetType = valueType
					}
				}
				
				if (targetType !== null) {
					sb.append(",\n")
					sb.append(spaces).append("\"target_type\": \"").append(targetType).append("\"")
				}
			}
			SpecialValueContract: {
				// SpecialValueContract is used for Preconditions and Postconditions (NEVER Invariants)
				if (contract instanceof Invariant) {
					System.err.println("WARNING: SpecialValueContract found in Invariant contract: " + fullName)
				}
				
				sb.append(spaces).append("\"type\": \"value_range\"")
				
				val checkValue = if (contractType.eClass.name.contains("no_special")) "no_special" else "has_special"
				sb.append(",\n")
				sb.append(spaces).append("\"check\": \"").append(checkValue).append("\"")
				
				sb.append(",\n")
				sb.append(spaces).append("\"target_type\": \"String\"")
			}
			CastTypeContract: {
				// CastTypeContract is used for Preconditions and Postconditions (NEVER Invariants)
				if (contract instanceof Invariant) {
					System.err.println("WARNING: CastTypeContract found in Invariant contract: " + fullName)
				}
				
				sb.append(spaces).append("\"type\": \"value_range\",\n")
				// Preconditions use "castable_to", Postconditions use "is_type"
				val check = if (contract instanceof Precondition) "castable_to" else "is_type"
				sb.append(spaces).append("\"check\": \"").append(check).append("\",\n")
				sb.append(spaces).append("\"target_type\": \"").append(contractType.type).append("\"")
			}
			IntervalContract: {
				// IntervalContract is used for Preconditions and Postconditions (NEVER Invariants)
				if (contract instanceof Invariant) {
					System.err.println("WARNING: IntervalContract found in Invariant contract: " + fullName)
				}
				
				sb.append(spaces).append("\"type\": \"value_range\",\n")
				val check = if (contract instanceof Precondition) "in_range" else "not_in_range"
				sb.append(spaces).append("\"check\": \"").append(check).append("\",\n")
				
				val belongOp = if (contractType.belongOp == "belongs_to") "BELONG" else "NOTBELONG"
				sb.append(spaces).append("\"belong_op\": \"").append(belongOp).append("\",\n")
				sb.append(spaces).append("\"target_type\": \"Double\"")
			}
			FieldRangeContract: {
				// FieldRangeContract is used for Column Filter contracts
				// It can be in Preconditions or Postconditions
				if (contract instanceof Invariant) {
					System.err.println("WARNING: FieldRangeContract found in Invariant contract: " + fullName)
				}
				
				sb.append(spaces).append("\"type\": \"value_range\"")
				
				// Determine check based on belongOp field
				val belongOp = contractType.belongOp
				var String checkValue = null
				
				if (contract instanceof Precondition) {
					// Precondition: belongs_to means "exists"
					checkValue = if (belongOp == "not_belongs_to") "not_exists" else "exists"
				} else if (contract instanceof Postcondition) {
					// Postcondition: not_belongs_to means "not_exists"
					checkValue = if (belongOp == "not_belongs_to") "not_exists" else "exists"
				}
				
				if (checkValue !== null) {
					sb.append(",\n")
					sb.append(spaces).append("\"check\": \"").append(checkValue).append("\",\n")
					sb.append(spaces).append("\"target_type\": \"String\"")
				} else {
					// Fallback if checkValue is still null
					sb.append(",\n")
					sb.append(spaces).append("\"check\": \"exists\",\n")
					sb.append(spaces).append("\"target_type\": \"String\"")
				}
			}
		}
		
		return sb.toString
	}
	
	def String generateConditionJson(IfClause clause, int indent) {
		val spaces = " ".repeat(indent)
		val sb = new StringBuilder
		
		if (clause.expression instanceof SimpleCondition) {
			val condition = clause.expression as SimpleCondition
			sb.append(spaces).append("\"condition_type\": \"")
			sb.append(getConditionTypeName(condition.condition))
			sb.append("\",\n")
			sb.append(spaces).append("\"belong_op\": \"")
			sb.append(if (condition.op == "belongs_to") "BELONG" else "NOTBELONG")
			sb.append("\"")
		} else if (clause.expression instanceof FieldRangeContract) {
			// Handle FieldRangeContract in if clause (for ColumnFilter invariants)
			val fieldRange = clause.expression as FieldRangeContract
			val belongOp = if (fieldRange.belongOp == "belongs_to") "BELONG" else "NOTBELONG"
			sb.append(spaces).append("\"condition_type\": \"field_range\",\n")
			sb.append(spaces).append("\"belong_op\": \"").append(belongOp).append("\"")
		}
		
		return sb.toString
	}
	
	def String generateConditionJson(ThenClause clause, int indent) {
		val spaces = " ".repeat(indent)
		val sb = new StringBuilder
		
		if (clause.expression instanceof SimpleCondition) {
			val condition = clause.expression as SimpleCondition
			val conditionType = getConditionTypeName(condition.condition)
			
			sb.append(spaces).append("\"result_type\": \"")
			sb.append(conditionType)
			sb.append("\",\n")
			sb.append(spaces).append("\"belong_op\": \"")
			sb.append(if (condition.op == "belongs_to") "BELONG" else "NOTBELONG")
			sb.append("\"")
			
			// Add target_type for cast_type conditions
			if (condition.condition instanceof CastTypeCheck) {
				val castCheck = condition.condition as CastTypeCheck
				sb.append(",\n")
				sb.append(spaces).append("\"target_type\": \"").append(castCheck.type).append("\"")
			}
			
			// Add target_type for fixed value conditions (mapping)
			if (condition.condition instanceof FixedImputeCheck) {
				sb.append(",\n")
				sb.append(spaces).append("\"target_type\": \"String\"")
			}
		}
		
		return sb.toString
	}
	
	def String extractCheckFromValueRange(ValueRangeContract contract) {
		val nodeText = org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode(contract)?.text ?: ""
		
		if (nodeText.contains("has_missing")) return "has_missing"
		if (nodeText.contains("no_missing")) return "no_missing"
		if (nodeText.contains("castable_to")) return "castable_to"
		if (nodeText.contains("in_range")) return "in_range"
		
		return null
	}
	
	def String extractTargetTypeFromValueRange(ValueRangeContract contract) {
		if (contract.value?.type !== null) {
			return contract.value.type
		}
		return null
	}
	
	def String extractCheckFromSpecialValue(SpecialValueContract contract) {
		val nodeText = org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode(contract)?.text ?: ""
		
		if (nodeText.contains("has_missing")) return "has_missing"
		if (nodeText.contains("no_missing")) return "no_missing"
		
		return null
	}
	
	def String extractTargetTypeFromSpecialValue(SpecialValueContract contract) {
		if (contract.field?.column !== null) {
			// Try to infer type from context or return a default
			return "String"
		}
		return null
	}
	
	def String getConditionTypeName(DataCondition condition) {
		switch condition {
			SpecialValueCheck: "special_value"
			CastTypeCheck: "cast_type"
			ValueCheck: "value"
			IntervalCheck: "interval"
			FixedImputeCheck: "fix_value"
			StatisticalImputeCheck: {
				val nodeText = org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode(condition)?.text ?: ""
				if (nodeText.contains("most_frequent")) return "most_frequent"
				if (nodeText.contains("mean")) return "mean"
				if (nodeText.contains("median")) return "median"
				if (nodeText.contains("interpolation")) return "interpolation"
				return "statistical_impute"
			}
			default: "unknown"
		}
	}
	
	def int getNextNodeId() {
		val id = nodeIdCounter
		nodeIdCounter++
		return id
	}
	
	def String getClosureType(Interval interval) {
		val nodeText = org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode(interval)?.text ?: ""
		
		// Check if it starts with infinity
		val startsWithInfinity = nodeText.contains("-Infinity") || nodeText.contains("-inf")
		
		if (nodeText.startsWith("[") && nodeText.endsWith("]")) return "closedClosed"
		if (nodeText.startsWith("[") && nodeText.endsWith(")")) {
			// If starts with -Infinity, use openClosed instead of closedOpen
			return if (startsWithInfinity) "openClosed" else "closedOpen"
		}
		if (nodeText.startsWith("(") && nodeText.endsWith("]")) return "openClosed"
		if (nodeText.startsWith("(") && nodeText.endsWith(")")) return "openOpen"
		
		return "closedOpen"
	}
	
	def String formatIntervalBound(IntervalBound bound) {
		if (bound === null) return "0"
		
		val nodeText = org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode(bound)?.text?.trim ?: ""
		
		// Check for infinity values - use large numbers instead of strings
		if (nodeText.equals("-inf") || nodeText.equals("-Infinity")) return "-999999999"
		if (nodeText.equals("inf") || nodeText.equals("Infinity")) return "999999999"
		
		// Return the actual value if present
		if (bound.value !== null && !bound.value.isEmpty) return bound.value
		
		// If no value found, check the raw text again for numeric values
		if (nodeText.matches("-?\\d+(\\.\\d+)?")) return nodeText
		
		return "0"
	}
	
	def String formatBoundValue(BoundValue bound) {
		if (bound === null) return "0.0"
		if (bound.value !== null) return bound.value
		
		val nodeText = org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode(bound)?.text?.trim ?: ""
		
		if (nodeText.equals("-inf")) return "0.0"
		if (nodeText.equals("inf")) return "1000000000"
		if (nodeText.equals("*")) return "0.0"
		
		return "0.0"
	}
	
	def boolean isInfinity(BoundValue bound) {
		if (bound === null) return false
		val nodeText = org.eclipse.xtext.nodemodel.util.NodeModelUtils.getNode(bound)?.text?.trim ?: ""
		return nodeText.equals("-inf") || nodeText.equals("inf") || nodeText.equals("*")
	}
	
	def String formatValue(Value value) {
		if (value.string !== null) return "\"" + value.string.replaceAll('"', '') + "\""
		if (value.number !== null) return value.number
		return "null"
	}
}