/*
 * generated by Xtext 2.40.0
 */
package xtext.json.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import xtext.json.workflowDSL.*

/**
 * Generates JSON representation from WorkflowDSL files.
 */
class WorkflowDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (workflow : resource.allContents.filter(Workflow).toIterable) {
			val fileName = workflow.name?.replaceAll('"', '') ?: "workflow"
			fsa.generateFile(fileName + '.json', workflow.toJson)
		}
	}
	
	def String toJson(Workflow workflow) {
		return workflow.convertToJson(0)
	}
	
	def String convertToJson(Workflow workflow, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"type\": \"workflow\",\n")
		sb.append(spaces(indent + 2) + "\"name\": \"" + (workflow.name?.replaceAll('"', '') ?: "") + "\",\n")
		sb.append(spaces(indent + 2) + "\"source\": " + workflow.source.convertToJson(indent + 2) + ",\n")
		sb.append(spaces(indent + 2) + "\"body\": " + workflow.body.convertToJson(indent + 2) + "\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(DataSource source, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"type\": \"data_source\",\n")
		sb.append(spaces(indent + 2) + "\"name\": \"" + source.name + "\",\n")
		sb.append(spaces(indent + 2) + "\"reader\": " + source.reader.convertToJson(indent + 2) + "\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(DataReader reader, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		switch reader {
			CSVReader: {
				sb.append(spaces(indent + 2) + "\"type\": \"csv_reader\",\n")
				sb.append(spaces(indent + 2) + "\"file_path\": " + reader.filePath.convertToJson(indent + 2))
				if (reader.delimiter !== null) {
					sb.append(",\n")
					sb.append(spaces(indent + 2) + "\"delimiter\": " + reader.delimiter.convertToJson(indent + 2))
				}
				sb.append("\n")
			}
			FileReader: {
				sb.append(spaces(indent + 2) + "\"type\": \"file_reader\",\n")
				sb.append(spaces(indent + 2) + "\"file_path\": " + reader.filePath.convertToJson(indent + 2) + "\n")
			}
		}
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(FilePath filePath, int indent) {
		return "{\n" + spaces(indent + 2) + "\"path\": \"" + (filePath.path?.replaceAll('"', '') ?: "") + "\"\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(Delimiter delimiter, int indent) {
		return "{\n" + spaces(indent + 2) + "\"value\": \"" + (delimiter.value?.replaceAll('"', '') ?: "") + "\"\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(WorkflowBody body, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"steps\": [\n")
		for (var i = 0; i < body.steps.size; i++) {
			sb.append(spaces(indent + 4) + body.steps.get(i).convertToJson(indent + 4))
			if (i < body.steps.size - 1) {
				sb.append(",")
			}
			sb.append("\n")
		}
		sb.append(spaces(indent + 2) + "]\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(Step step, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"type\": \"step\",\n")
		sb.append(spaces(indent + 2) + "\"name\": \"" + step.name + "\",\n")
		sb.append(spaces(indent + 2) + "\"transformation\": " + step.transformation.convertToJson(indent + 2))
		if (step.target !== null) {
			sb.append(",\n")
			sb.append(spaces(indent + 2) + "\"target\": \"" + step.target + "\"")
		}
		if (step.contracts !== null) {
			sb.append(",\n")
			sb.append(spaces(indent + 2) + "\"contracts\": " + step.contracts.convertToJson(indent + 2))
		}
		sb.append("\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(ContractBlock contractBlock, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"contracts\": [\n")
		for (var i = 0; i < contractBlock.contracts.size; i++) {
			sb.append(spaces(indent + 4) + contractBlock.contracts.get(i).convertToJson(indent + 4))
			if (i < contractBlock.contracts.size - 1) {
				sb.append(",")
			}
			sb.append("\n")
		}
		sb.append(spaces(indent + 2) + "]\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(Contract contract, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		switch contract {
			Precondition: {
				sb.append(spaces(indent + 2) + "\"type\": \"precondition\"")
			}
			Postcondition: {
				sb.append(spaces(indent + 2) + "\"type\": \"postcondition\"")
			}
			Invariant: {
				sb.append(spaces(indent + 2) + "\"type\": \"invariant\"")
			}
		}
		if (contract.name !== null) {
			sb.append(",\n")
			sb.append(spaces(indent + 2) + "\"name\": " + contract.name.convertToJson(indent + 2))
		}
		if (contract.body !== null) {
			sb.append(",\n")
			sb.append(spaces(indent + 2) + "\"body\": " + contract.body.convertToJson(indent + 2))
		}
		sb.append("\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(ContractName name, int indent) {
		return "{\n" + spaces(indent + 2) + "\"name\": \"" + (name.name?.replaceAll('"', '') ?: "") + "\"\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(ContractBody body, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		if (body.type !== null) {
			sb.append(spaces(indent + 2) + "\"contract_type\": " + body.type.convertToJson(indent + 2))
		}
		sb.append("\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(ContractType contractType, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		switch contractType {
			ValueRangeContract: {
				sb.append(spaces(indent + 2) + "\"type\": \"value_range\",\n")
				sb.append(spaces(indent + 2) + "\"field\": " + contractType.field.convertToJson(indent + 2) + ",\n")
				sb.append(spaces(indent + 2) + "\"value\": " + contractType.value.convertToJson(indent + 2))
			}
			ConditionContract: {
				sb.append(spaces(indent + 2) + "\"type\": \"condition\",\n")
				sb.append(spaces(indent + 2) + "\"if_clause\": " + contractType.ifClause.convertToJson(indent + 2) + ",\n")
				sb.append(spaces(indent + 2) + "\"then_clause\": " + contractType.thenClause.convertToJson(indent + 2))
			}
			SpecialValueContract: {
				sb.append(spaces(indent + 2) + "\"type\": \"special_value\",\n")
				sb.append(spaces(indent + 2) + "\"field\": " + contractType.field.convertToJson(indent + 2))
			}
			CastTypeContract: {
				sb.append(spaces(indent + 2) + "\"type\": \"cast_type\",\n")
				sb.append(spaces(indent + 2) + "\"cast_type_name\": \"" + contractType.type + "\",\n")
				sb.append(spaces(indent + 2) + "\"field\": " + contractType.field.convertToJson(indent + 2))
			}
		}
		sb.append("\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(ContractField field, int indent) {
		return "{\n" + spaces(indent + 2) + "\"column\": " + field.column.convertToJson(indent + 2) + "\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(Transformation transformation, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		switch transformation {
			RowFilter: {
				sb.append(spaces(indent + 2) + "\"type\": \"row_filter\",\n")
				sb.append(spaces(indent + 2) + "\"condition\": " + transformation.condition.convertToJson(indent + 2))
			}
			ColumnFilter: {
				sb.append(spaces(indent + 2) + "\"type\": \"column_filter\",\n")
				sb.append(spaces(indent + 2) + "\"columns\": " + transformation.columns.convertToJson(indent + 2))
			}
			ValueMapping: {
				sb.append(spaces(indent + 2) + "\"type\": \"value_mapping\",\n")
				sb.append(spaces(indent + 2) + "\"column\": " + transformation.column.convertToJson(indent + 2) + ",\n")
				sb.append(spaces(indent + 2) + "\"rules\": " + transformation.rules.convertToJson(indent + 2) + ",\n")
				sb.append(spaces(indent + 2) + "\"mode\": " + transformation.mode.convertToJson(indent + 2))
			}
			MathOp: {
				sb.append(spaces(indent + 2) + "\"type\": \"math_operation\",\n")
				sb.append(spaces(indent + 2) + "\"expression\": " + transformation.expression.convertToJson(indent + 2) + ",\n")
				sb.append(spaces(indent + 2) + "\"new_name\": \"" + transformation.newName + "\"")
			}
			TypeConversion: {
				sb.append(spaces(indent + 2) + "\"type\": \"type_conversion\",\n")
				sb.append(spaces(indent + 2) + "\"columns\": " + transformation.columns.convertToJson(indent + 2))
			}
			Imputation: {
				sb.append(spaces(indent + 2) + "\"type\": \"imputation\",\n")
				sb.append(spaces(indent + 2) + "\"columns\": " + transformation.columns.convertToJson(indent + 2) + ",\n")
				sb.append(spaces(indent + 2) + "\"method\": " + transformation.method.convertToJson(indent + 2))
			}
			Join: {
				sb.append(spaces(indent + 2) + "\"type\": \"join\",\n")
				sb.append(spaces(indent + 2) + "\"left\": \"" + transformation.left + "\",\n")
				sb.append(spaces(indent + 2) + "\"right\": \"" + transformation.right + "\",\n")
				sb.append(spaces(indent + 2) + "\"spec\": " + transformation.spec.convertToJson(indent + 2))
			}
			default: {
				sb.append(spaces(indent + 2) + "\"type\": \"unknown_transformation\"")
			}
		}
		sb.append("\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(Column column, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"name\": \"" + column.name + "\"")
		if (column.table !== null) {
			sb.append(",\n")
			sb.append(spaces(indent + 2) + "\"table\": \"" + column.table + "\",\n")
			sb.append(spaces(indent + 2) + "\"column\": \"" + column.column + "\"")
		}
		sb.append("\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(ColumnList columnList, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"columns\": [\n")
		for (var i = 0; i < columnList.columns.size; i++) {
			sb.append(spaces(indent + 4) + columnList.columns.get(i).convertToJson(indent + 4))
			if (i < columnList.columns.size - 1) {
				sb.append(",")
			}
			sb.append("\n")
		}
		sb.append(spaces(indent + 2) + "]\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	// Helper methods for basic types
	def String convertToJson(FilterCondition condition, int indent) {
		return "{\n" + spaces(indent + 2) + "\"type\": \"filter_condition\"\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(MappingRules rules, int indent) {
		return "{\n" + spaces(indent + 2) + "\"type\": \"mapping_rules\"\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(MappingMode mode, int indent) {
		return "{\n" + spaces(indent + 2) + "\"type\": \"mapping_mode\"\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(MathExpression expression, int indent) {
		return "{\n" + spaces(indent + 2) + "\"type\": \"math_expression\"\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(ImputeMethod method, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		switch method {
			FixedImpute: {
				sb.append(spaces(indent + 2) + "\"type\": \"fixed\"")
			}
			default: {
				sb.append(spaces(indent + 2) + "\"type\": \"other\"")
			}
		}
		sb.append("\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(JoinSpec spec, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"join_type\": \"" + spec.type + "\",\n")
		sb.append(spaces(indent + 2) + "\"conditions\": " + spec.conditions.convertToJson(indent + 2))
		if (spec.options !== null) {
			sb.append(",\n")
			sb.append(spaces(indent + 2) + "\"options\": " + spec.options.convertToJson(indent + 2))
		}
		sb.append("\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(JoinConditions conditions, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"conditions\": [\n")
		for (var i = 0; i < conditions.conditions.size; i++) {
			sb.append(spaces(indent + 4) + conditions.conditions.get(i).convertToJson(indent + 4))
			if (i < conditions.conditions.size - 1) {
				sb.append(",")
			}
			sb.append("\n")
		}
		sb.append(spaces(indent + 2) + "]\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(JoinCondition condition, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"left\": " + condition.left.convertToJson(indent + 2) + ",\n")
		sb.append(spaces(indent + 2) + "\"right\": " + condition.right.convertToJson(indent + 2) + ",\n")
		val comparator = if (condition.comparator !== null) condition.comparator else "="
		sb.append(spaces(indent + 2) + "\"comparator\": \"" + comparator + "\"\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	def String convertToJson(JoinOptions options, int indent) {
		val sb = new StringBuilder
		sb.append("{\n")
		sb.append(spaces(indent + 2) + "\"left_suffix\": \"" + (options.leftSuffix?.replaceAll('"', '') ?: "") + "\",\n")
		sb.append(spaces(indent + 2) + "\"right_suffix\": \"" + (options.rightSuffix?.replaceAll('"', '') ?: "") + "\"\n")
		sb.append(spaces(indent) + "}")
		return sb.toString
	}
	
	// Helper methods
	def String convertToJson(ContractValue value, int indent) {
		return "{\n" + spaces(indent + 2) + "\"type\": \"contract_value\"\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(IfClause clause, int indent) {
		return "{\n" + spaces(indent + 2) + "\"type\": \"if_clause\"\n" + spaces(indent) + "}"
	}
	
	def String convertToJson(ThenClause clause, int indent) {
		return "{\n" + spaces(indent + 2) + "\"type\": \"then_clause\"\n" + spaces(indent) + "}"
	}
	
	def String spaces(int count) {
		val sb = new StringBuilder
		for (var i = 0; i < count; i++) {
			sb.append(" ")
		}
		return sb.toString
	}
}