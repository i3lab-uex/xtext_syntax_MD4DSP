grammar xtext.json.WorkflowDSL with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate workflowDSL "http://www.json.xtext/WorkflowDSL"

Workflow:
    "workflow" name=STRING "{" source=DataSource body=WorkflowBody "}";

DataSource:
    "source" name=ID "=" reader=DataReader;

DataReader:
    CSVReader | FileReader;

CSVReader:
    "read_csv" "(" filePath=FilePath ("," delimiter=Delimiter)? ")";

FileReader:
    "read_file" "(" filePath=FilePath ")";

FilePath:
    path=STRING;

Delimiter:
    "," | ";" | "\t" | "|" | value=STRING;

WorkflowBody:
    steps+=Step*;

Step:
    name=ID "=" transformation=Transformation ("|>" target=ID)? contracts=ContractBlock?;

ContractBlock:
    "contracts" "{" contracts+=Contract* "}";

Contract:
    Precondition | Postcondition | Invariant;

Precondition:
    "precondition" name=ContractName "{" body=ContractBody "}";

Postcondition:
    "postcondition" name=ContractName "{" body=ContractBody "}";

Invariant:
    "invariant" name=ContractName "{" body=ContractBody "}";

ContractName:
    name=STRING | name=ID;

ContractBody:
    type=ContractType;

ContractType:
    ValueRangeContract
    | ConditionContract
    | SpecialValueContract
    | CastTypeContract;

ValueRangeContract:
    "value_range" "(" field=ContractField "," value=ContractValue ")";

ContractField:
    "input" "." column=Column
    | "output" "." column=Column;

ContractValue:
    "castable_to" type=Type
    | "in_range" bounds=RangeBounds
    | "matches" value=Value;

Type:
    "Integer" | "Double" | "String" | "Boolean";

ConditionContract:
    "condition" "{" ifClause=IfClause thenClause=ThenClause "}";

IfClause:
    "if" field=ContractField op=BelongOp condition=DataCondition;

ThenClause:
    "then" field=ContractField op=BelongOp result=DataResult;

BelongOp:
    "belongs_to" | "not_belongs_to";

DataCondition:
    SpecialValueCheck | CastTypeCheck | ValueCheck;

SpecialValueCheck:
    "special_values";

CastTypeCheck:
    "type" type=Type;

ValueCheck:
    "value" value=Value;

DataResult:
    SpecialValueCheck | CastTypeCheck | ValueCheck;

SpecialValueContract:
    "no_special_values" "(" field=ContractField ")"
    | "has_special_values" "(" field=ContractField ")";

CastTypeContract:
    "castable_to" type=Type "(" field=ContractField ")"
    | "is_type" type=Type "(" field=ContractField ")";

Transformation:
    RowFilter
    | ColumnFilter  
    | Mapping
    | MathOp
    | Binner
    | TypeConversion
    | Imputation
    | OutlierTreatment
    | Join;

RowFilter:
    "filter_rows" "{" condition=FilterCondition "}";

FilterCondition:
    MissingFilter | RangeFilter | StringFilter;

MissingFilter:
    "missing" "(" columns=ColumnList "," includeExclude=IncludeExclude ")";

RangeFilter:
    "range" "(" column=Column "," bounds=RangeBounds "," includeExclude=IncludeExclude ")";

RangeBounds:
    "[" lower=BoundValue "," upper=BoundValue "]"
    | "[" lower=BoundValue "," upper=BoundValue ")"
    | "(" lower=BoundValue "," upper=BoundValue "]"
    | "(" lower=BoundValue "," upper=BoundValue ")";

BoundValue:
    value=Number | "*" | "inf" | "-inf";

StringFilter:
    "matches" "(" column=Column "," pattern=Pattern "," includeExclude=IncludeExclude ")"
    | "like" "(" column=Column "," pattern=Pattern "," includeExclude=IncludeExclude ")";

Pattern:
    value=STRING | regex=Regex;

IncludeExclude:
    "include" | "exclude";

ColumnFilter:
    "select_columns" "{" columns=ColumnList "}"
    | "drop_columns" "{" columns=ColumnList "}"
    | "keep" "{" columns=ColumnList "}"
    | "remove" "{" columns=ColumnList "}";

Mapping:
    ValueMapping | SubstringMapping;

ValueMapping:
    "map" "(" column=Column ")" "{" rules=MappingRules "}" mode=MappingMode;

MappingRules:
    (rules+=MappingRule ("," rules+=MappingRule)*)?;

MappingRule:
    from=STRING "->" to=STRING
    | pattern=Pattern "=>" to=STRING;

SubstringMapping:
    "replace" "(" column=Column "," from=STRING "," to=STRING ")" mode=MappingMode;

MappingMode:
    "replace" | "as" newName=ID;

MathOp:
    "math" "(" expression=MathExpression ")" "as" newName=ID;

MathExpression:
    Primary (operator=Operator right=Primary)*;

Primary:
    operand=Operand | "(" expression=MathExpression ")" | call=FunctionCall;

FunctionCall:
    function=Function "(" (operands+=Operand ("," operands+=Operand)*)? ")";

Function:
    "abs" | "sqrt" | "pow" | "log" | "exp" 
    | "sin" | "cos" | "tan" | "round" | "ceil" | "floor";

Operand:
    column=Column | number=Number | string=STRING;

Operator:
    "+" | "-" | "*" | "/" | "%" | "^";

Binner:
    "bin" "(" column=Column ")" "{" definitions=BinDefinitions "}" mode=BinMode;

BinDefinitions:
    (definitions+=BinDef ("," definitions+=BinDef)*)?;

BinDef:
    name=BinName ":" interval=Interval;

BinName:
    name=STRING;

Interval:
    "[" lower=IntervalBound "," upper=IntervalBound "]"
    | "[" lower=IntervalBound "," upper=IntervalBound ")"
    | "(" lower=IntervalBound "," upper=IntervalBound "]"
    | "(" lower=IntervalBound "," upper=IntervalBound ")";

IntervalBound:
    value=Number | "-inf" | "inf" | "-Infinity" | "Infinity";

BinMode:
    "replace" | "as" newName=ID;

TypeConversion:
    "to_numeric" "(" columns=ColumnList ")" separator=DecimalSeparator?
    | "to_string" "(" columns=ColumnList ")"
    | "to_categorical" "(" columns=ColumnList ")"
    | "to_boolean" "(" columns=ColumnList ")"
    | "to_date" "(" columns=ColumnList "," format=DateFormat? ")";

DecimalSeparator:
    "separator" "=" ("." | ",");

DateFormat:
    "format" "=" format=STRING;

Imputation:
    "impute" "(" columns=ColumnList ")" "{" method=ImputeMethod "}";

ImputeMethod:
    FixedImpute
    | StatisticalImpute
    | SequentialImpute
    | AdvancedImpute;

FixedImpute:
    "fixed" "=" values=ValueList;

ValueList:
    value=Value | "[" (values+=Value ("," values+=Value)*)? "]";

Value:
    number=Number | string=STRING | "null";

StatisticalImpute:
    "mean"
    | "median"
    | "mode"
    | "most_frequent"
    | "max"
    | "min";

SequentialImpute:
    "forward_fill"
    | "backward_fill"
    | "previous_value"
    | "next_value";

AdvancedImpute:
    "interpolation" type=InterpolationType?
    | "moving_average" ("window" "=" windowSize=Number)?
    | "linear"
    | "polynomial" ("degree" "=" degree=Number)?
    | "spline";

InterpolationType:
    "linear" | "polynomial" | "spline";

OutlierTreatment:
    "outliers" "(" columns=ColumnList ")" "{" strategy=OutlierStrategy "}";

OutlierStrategy:
    replacement=ReplacementStrategy method=DetectionMethod options=OutlierOptions?;

ReplacementStrategy:
    "replace_closest"
    | "replace_missing"
    | "replace_by_closest"
    | "replace_with" "=" value=Number
    | "remove"
    | "cap";

DetectionMethod:
    IQRMethod | ZScoreMethod | PercentileMethod;

IQRMethod:
    "iqr" (params+=IQRParam)*;

IQRParam:
    "scalar" "=" scalar=Number
    | "estimation" "=" estimation=EstimationType;

EstimationType:
    "R_4" | "R_7" | "R_8";

ZScoreMethod:
    "zscore" ("threshold" "=" threshold=Number)?;

PercentileMethod:
    "percentile" "lower" "=" lower=Number "upper" "=" upper=Number;

OutlierOptions:
    "scope" "=" scope=OutlierScope;

OutlierScope:
    "all" | "all_outliers" | "lower_only" | "upper_only";

Join:
    "join" "(" left=ID "," right=ID ")" "{" spec=JoinSpec "}";

JoinSpec:
    type=JoinType "on" conditions=JoinConditions options=JoinOptions?;

JoinType:
    "inner" | "left" | "right" | "full" | "cross";

JoinConditions:
    conditions+=JoinCondition ("and" conditions+=JoinCondition)*;

JoinCondition:
    left=Column "=" right=Column
    | left=Column comparator=Comparator right=Column;

Comparator:
    "=" | "==" | "!=" | "<" | ">" | "<=" | ">=";

JoinOptions:
    "suffix" "=" "(" leftSuffix=STRING "," rightSuffix=STRING ")";

Column:
    name=ID | table=ID "." column=ID;

ColumnList:
    columns+=Column ("," columns+=Column)*
    | "*";

Number:
    INT ('.' INT)? | '.' INT;

Integer returns ecore::EInt:
    INT;

Float returns ecore::EFloat:
    INT '.' INT | '.' INT | INT '.';

Regex:
    '/' pattern=STRING '/' flags=STRING?;

terminal COMMENT:
    '//' !('\n'|'\r')* ('\r'? '\n')?
    | '/*' -> '*/';