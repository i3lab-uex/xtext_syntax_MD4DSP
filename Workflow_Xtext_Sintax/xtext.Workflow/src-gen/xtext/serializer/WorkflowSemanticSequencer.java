/*
 * generated by Xtext 2.37.0
 */
package xtext.serializer;

import Workflow.CastType;
import Workflow.Categorical;
import Workflow.Continuous;
import Workflow.DataDictionary;
import Workflow.DataProcessing;
import Workflow.Date;
import Workflow.DateRange;
import Workflow.DerivedField;
import Workflow.DerivedValue;
import Workflow.DiscretizeBin;
import Workflow.Field;
import Workflow.FieldRange;
import Workflow.FilterValue;
import Workflow.FixValue;
import Workflow.Interval;
import Workflow.IntervalDate;
import Workflow.Join;
import Workflow.Link;
import Workflow.Map;
import Workflow.MathOp;
import Workflow.NumOp;
import Workflow.PMMLModel;
import Workflow.Primitive;
import Workflow.Range;
import Workflow.SpecialValues;
import Workflow.Test;
import Workflow.ValueField;
import Workflow.Workflow;
import Workflow.WorkflowPackage;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.services.WorkflowGrammarAccess;

@SuppressWarnings("all")
public class WorkflowSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private WorkflowGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == WorkflowPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case WorkflowPackage.CAST_TYPE:
				sequence_CastType(context, (CastType) semanticObject); 
				return; 
			case WorkflowPackage.CATEGORICAL:
				sequence_Categorical(context, (Categorical) semanticObject); 
				return; 
			case WorkflowPackage.CONTINUOUS:
				sequence_Continuous(context, (Continuous) semanticObject); 
				return; 
			case WorkflowPackage.DATA_DICTIONARY:
				sequence_DataDictionary(context, (DataDictionary) semanticObject); 
				return; 
			case WorkflowPackage.DATA_PROCESSING:
				sequence_DataProcessing(context, (DataProcessing) semanticObject); 
				return; 
			case WorkflowPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case WorkflowPackage.DATE_RANGE:
				sequence_DateRange(context, (DateRange) semanticObject); 
				return; 
			case WorkflowPackage.DERIVED_FIELD:
				sequence_DerivedField(context, (DerivedField) semanticObject); 
				return; 
			case WorkflowPackage.DERIVED_VALUE:
				sequence_DerivedValue(context, (DerivedValue) semanticObject); 
				return; 
			case WorkflowPackage.DISCRETIZE_BIN:
				sequence_DiscretizeBin(context, (DiscretizeBin) semanticObject); 
				return; 
			case WorkflowPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case WorkflowPackage.FIELD_RANGE:
				sequence_FieldRange(context, (FieldRange) semanticObject); 
				return; 
			case WorkflowPackage.FILTER_VALUE:
				sequence_FilterValue(context, (FilterValue) semanticObject); 
				return; 
			case WorkflowPackage.FIX_VALUE:
				sequence_FixValue(context, (FixValue) semanticObject); 
				return; 
			case WorkflowPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case WorkflowPackage.INTERVAL_DATE:
				sequence_IntervalDate(context, (IntervalDate) semanticObject); 
				return; 
			case WorkflowPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case WorkflowPackage.LINK:
				sequence_Link(context, (Link) semanticObject); 
				return; 
			case WorkflowPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case WorkflowPackage.MATH_OP:
				sequence_MathOp(context, (MathOp) semanticObject); 
				return; 
			case WorkflowPackage.NUM_OP:
				sequence_NumOp(context, (NumOp) semanticObject); 
				return; 
			case WorkflowPackage.PMML_MODEL:
				sequence_PMMLModel(context, (PMMLModel) semanticObject); 
				return; 
			case WorkflowPackage.PRIMITIVE:
				sequence_Primitive(context, (Primitive) semanticObject); 
				return; 
			case WorkflowPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case WorkflowPackage.SPECIAL_VALUES:
				sequence_SpecialValues(context, (SpecialValues) semanticObject); 
				return; 
			case WorkflowPackage.TEST:
				sequence_Test(context, (Test) semanticObject); 
				return; 
			case WorkflowPackage.VALUE_FIELD:
				sequence_ValueField(context, (ValueField) semanticObject); 
				return; 
			case WorkflowPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns CastType
	 *     CastType returns CastType
	 *
	 * Constraint:
	 *     (name=EString type=DataType?)
	 * </pre>
	 */
	protected void sequence_CastType(ISerializationContext context, CastType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataField returns Categorical
	 *     Argument returns Categorical
	 *     Categorical returns Categorical
	 *
	 * Constraint:
	 *     (
	 *         id?='id'? 
	 *         target?='target'? 
	 *         ordinal?='ordinal'? 
	 *         name=EString 
	 *         dataType=DataType? 
	 *         displayName=EString? 
	 *         (in+=[DataField|EString] in+=[DataField|EString]*)? 
	 *         out=[DataField|EString]? 
	 *         (validValues+=ValueField validValues+=ValueField*)? 
	 *         (invalidValues+=ValueField invalidValues+=ValueField*)? 
	 *         (missingValues+=ValueField missingValues+=ValueField*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Categorical(ISerializationContext context, Categorical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataField returns Continuous
	 *     Argument returns Continuous
	 *     Continuous returns Continuous
	 *
	 * Constraint:
	 *     (
	 *         id?='id'? 
	 *         target?='target'? 
	 *         name=EString 
	 *         dataType=DataType? 
	 *         displayName=EString? 
	 *         numDecimals=EIntegerObject? 
	 *         (in+=[DataField|EString] in+=[DataField|EString]*)? 
	 *         out=[DataField|EString]? 
	 *         (validValues+=ValueField validValues+=ValueField*)? 
	 *         (invalidValues+=ValueField invalidValues+=ValueField*)? 
	 *         (missingValues+=ValueField missingValues+=ValueField*)? 
	 *         interval+=Interval 
	 *         interval+=Interval*
	 *     )
	 * </pre>
	 */
	protected void sequence_Continuous(ISerializationContext context, Continuous semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Argument returns DataDictionary
	 *     DataDictionary returns DataDictionary
	 *
	 * Constraint:
	 *     (name=EString fileName=EString? in=[DataDictionary|EString]? out=[DataDictionary|EString]? (datafield+=DataField datafield+=DataField*)?)
	 * </pre>
	 */
	protected void sequence_DataDictionary(ISerializationContext context, DataDictionary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProcessingStep returns DataProcessing
	 *     DataProcessing returns DataProcessing
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         origin_function=EString? 
	 *         outgoing=[Link|EString]? 
	 *         incoming=[Link|EString]? 
	 *         in+=[Argument|EString] 
	 *         in+=[Argument|EString]* 
	 *         out+=[Argument|EString] 
	 *         out+=[Argument|EString]* 
	 *         initial_accumulated_processing=[DataProcessing|EString]? 
	 *         inputPort+=DataDictionary 
	 *         inputPort+=DataDictionary* 
	 *         outputPort+=DataDictionary 
	 *         outputPort+=DataDictionary* 
	 *         (parameter+=Parameter parameter+=Parameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_DataProcessing(ISerializationContext context, DataProcessing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns DateRange
	 *     MatchingValue returns DateRange
	 *     DateRange returns DateRange
	 *
	 * Constraint:
	 *     (name=EString clousure=ClosureType? max=EString? min=EString?)
	 * </pre>
	 */
	protected void sequence_DateRange(ISerializationContext context, DateRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataField returns Date
	 *     Argument returns Date
	 *     Date returns Date
	 *
	 * Constraint:
	 *     (
	 *         id?='id'? 
	 *         target?='target'? 
	 *         name=EString 
	 *         dataType=DataType? 
	 *         displayName=EString? 
	 *         format=EString? 
	 *         (in+=[DataField|EString] in+=[DataField|EString]*)? 
	 *         out=[DataField|EString]? 
	 *         (validValues+=ValueField validValues+=ValueField*)? 
	 *         (invalidValues+=ValueField invalidValues+=ValueField*)? 
	 *         (missingValues+=ValueField missingValues+=ValueField*)? 
	 *         intervaldate+=IntervalDate 
	 *         intervaldate+=IntervalDate*
	 *     )
	 * </pre>
	 */
	protected void sequence_Date(ISerializationContext context, Date semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns DerivedField
	 *     DerivedField returns DerivedField
	 *
	 * Constraint:
	 *     (name=EString der_dataField=[DataField|EString])
	 * </pre>
	 */
	protected void sequence_DerivedField(ISerializationContext context, DerivedField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.DERIVED_FIELD__DER_DATA_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.DERIVED_FIELD__DER_DATA_FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDerivedFieldAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDerivedFieldAccess().getDer_dataFieldDataFieldEStringParserRuleCall_4_0_1(), semanticObject.eGet(WorkflowPackage.Literals.DERIVED_FIELD__DER_DATA_FIELD, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns DerivedValue
	 *     DerivedValue returns DerivedValue
	 *
	 * Constraint:
	 *     (name=EString imputeValue=SpecialValue? type=DerivedType?)
	 * </pre>
	 */
	protected void sequence_DerivedValue(ISerializationContext context, DerivedValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns DiscretizeBin
	 *     DiscretizeBin returns DiscretizeBin
	 *
	 * Constraint:
	 *     (name=EString binValue=EString? interval+=Interval interval+=Interval*)
	 * </pre>
	 */
	protected void sequence_DiscretizeBin(ISerializationContext context, DiscretizeBin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns FieldRange
	 *     FieldRange returns FieldRange
	 *
	 * Constraint:
	 *     (name=EString operator=Operator? dataField+=[DataField|EString] dataField+=[DataField|EString]*)
	 * </pre>
	 */
	protected void sequence_FieldRange(ISerializationContext context, FieldRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Field
	 *     Operand returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=EString next_operand=[Operand|EString]? previous_operand=[Operand|EString]? datafield=[DataField|EString])
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns FilterValue
	 *     FilterValue returns FilterValue
	 *
	 * Constraint:
	 *     (name=EString filterType=FilterType? (primitive+=Primitive primitive+=Primitive*)? (matchingvalue+=MatchingValue matchingvalue+=MatchingValue*)?)
	 * </pre>
	 */
	protected void sequence_FilterValue(ISerializationContext context, FilterValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns FixValue
	 *     Operand returns FixValue
	 *     FixValue returns FixValue
	 *
	 * Constraint:
	 *     (name=EString imputeValue=SpecialValue? next_operand=[Operand|EString]? previous_operand=[Operand|EString]? value=Primitive)
	 * </pre>
	 */
	protected void sequence_FixValue(ISerializationContext context, FixValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntervalDate returns IntervalDate
	 *
	 * Constraint:
	 *     (rightMargin=EString? clousure=ClosureType? leftMargin=EString?)
	 * </pre>
	 */
	protected void sequence_IntervalDate(ISerializationContext context, IntervalDate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     (leftMargin=EFloat? rightMargin=EFloat? clousure=ClosureType?)
	 * </pre>
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (name=EString operand+=Operand operand+=Operand*)
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns Link
	 *
	 * Constraint:
	 *     (name=EString source=[ProcessingStep|EString] target=[ProcessingStep|EString])
	 * </pre>
	 */
	protected void sequence_Link(ISerializationContext context, Link semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.LINK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.LINK__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.LINK__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.LINK__SOURCE));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.LINK__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.LINK__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinkAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLinkAccess().getSourceProcessingStepEStringParserRuleCall_4_0_1(), semanticObject.eGet(WorkflowPackage.Literals.LINK__SOURCE, false));
		feeder.accept(grammarAccess.getLinkAccess().getTargetProcessingStepEStringParserRuleCall_6_0_1(), semanticObject.eGet(WorkflowPackage.Literals.LINK__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Map
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (name=EString inValue=EString? outvalue=EString? mapOperation=MapOperation?)
	 * </pre>
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns MathOp
	 *     MathOp returns MathOp
	 *
	 * Constraint:
	 *     (name=EString operator=MathOperator? operand+=Operand operand+=Operand*)
	 * </pre>
	 */
	protected void sequence_MathOp(ISerializationContext context, MathOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns NumOp
	 *     NumOp returns NumOp
	 *
	 * Constraint:
	 *     (name=EString imputeValue=SpecialValue? operation=Operation?)
	 * </pre>
	 */
	protected void sequence_NumOp(ISerializationContext context, NumOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProcessingStep returns PMMLModel
	 *     PMMLModel returns PMMLModel
	 *
	 * Constraint:
	 *     (
	 *         onlyPredictions?='onlyPredictions'? 
	 *         name=EString 
	 *         origin_function=EString? 
	 *         filePath=EString? 
	 *         outgoing=[Link|EString]? 
	 *         incoming=[Link|EString]? 
	 *         in+=[Argument|EString] 
	 *         in+=[Argument|EString]* 
	 *         out+=[Argument|EString] 
	 *         out+=[Argument|EString]* 
	 *         inputPort+=DataDictionary 
	 *         inputPort+=DataDictionary* 
	 *         outputPort+=DataDictionary 
	 *         outputPort+=DataDictionary* 
	 *         test=Test?
	 *     )
	 * </pre>
	 */
	protected void sequence_PMMLModel(ISerializationContext context, PMMLModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Primitive
	 *     Primitive returns Primitive
	 *
	 * Constraint:
	 *     (name=EString value=EString? dataType=DataType?)
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, Primitive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Range
	 *     MatchingValue returns Range
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (
	 *         minInfinity?='minInfinity'? 
	 *         maxInfinity?='maxInfinity'? 
	 *         name=EString 
	 *         min=EFloat? 
	 *         max=EFloat? 
	 *         clousure=ClosureType?
	 *     )
	 * </pre>
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns SpecialValues
	 *     MatchingValue returns SpecialValues
	 *     SpecialValues returns SpecialValues
	 *
	 * Constraint:
	 *     (name=EString specialType=SpecialValue?)
	 * </pre>
	 */
	protected void sequence_SpecialValues(ISerializationContext context, SpecialValues semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Test returns Test
	 *
	 * Constraint:
	 *     (path=EString? trainSize=EFloat? testSize=EFloat?)
	 * </pre>
	 */
	protected void sequence_Test(ISerializationContext context, Test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueField returns ValueField
	 *
	 * Constraint:
	 *     (value=EString? count=EInt?)
	 * </pre>
	 */
	protected void sequence_ValueField(ISerializationContext context, ValueField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (name=EString dataprocessing+=ProcessingStep dataprocessing+=ProcessingStep* (link+=Link link+=Link*)?)
	 * </pre>
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
