/*
 * generated by Xtext 2.40.0
 */
package xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.services.WorkflowGrammarAccess;
import xtext.workflow.AWS;
import xtext.workflow.AmazonECS;
import xtext.workflow.AmazonS3;
import xtext.workflow.AzureBlob;
import xtext.workflow.AzureCI;
import xtext.workflow.CastType;
import xtext.workflow.Categorical;
import xtext.workflow.Continuous;
import xtext.workflow.Contract;
import xtext.workflow.Credentials;
import xtext.workflow.DataDictionary;
import xtext.workflow.DataProcessing;
import xtext.workflow.Database;
import xtext.workflow.Date;
import xtext.workflow.DateRange;
import xtext.workflow.DerivedField;
import xtext.workflow.DerivedValue;
import xtext.workflow.DevelopmentTool;
import xtext.workflow.DiscretizeBin;
import xtext.workflow.Field;
import xtext.workflow.FieldRange;
import xtext.workflow.File;
import xtext.workflow.FilterValue;
import xtext.workflow.FixValue;
import xtext.workflow.Interval;
import xtext.workflow.IntervalDate;
import xtext.workflow.Join;
import xtext.workflow.Link;
import xtext.workflow.Local;
import xtext.workflow.LocalFolder;
import xtext.workflow.Map;
import xtext.workflow.MathOp;
import xtext.workflow.NumOp;
import xtext.workflow.OAuth2;
import xtext.workflow.PMMLModel;
import xtext.workflow.Primitive;
import xtext.workflow.Range;
import xtext.workflow.SSL;
import xtext.workflow.SpecialValues;
import xtext.workflow.Table;
import xtext.workflow.Test;
import xtext.workflow.ValueField;
import xtext.workflow.Workflow;
import xtext.workflow.WorkflowPackage;

@SuppressWarnings("all")
public class WorkflowSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private WorkflowGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == WorkflowPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case WorkflowPackage.AWS:
				sequence_AWS(context, (AWS) semanticObject); 
				return; 
			case WorkflowPackage.AMAZON_ECS:
				sequence_AmazonECS(context, (AmazonECS) semanticObject); 
				return; 
			case WorkflowPackage.AMAZON_S3:
				sequence_AmazonS3(context, (AmazonS3) semanticObject); 
				return; 
			case WorkflowPackage.AZURE_BLOB:
				sequence_AzureBlob(context, (AzureBlob) semanticObject); 
				return; 
			case WorkflowPackage.AZURE_CI:
				sequence_AzureCI(context, (AzureCI) semanticObject); 
				return; 
			case WorkflowPackage.CAST_TYPE:
				sequence_CastType(context, (CastType) semanticObject); 
				return; 
			case WorkflowPackage.CATEGORICAL:
				sequence_Categorical(context, (Categorical) semanticObject); 
				return; 
			case WorkflowPackage.CONTINUOUS:
				sequence_Continuous(context, (Continuous) semanticObject); 
				return; 
			case WorkflowPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case WorkflowPackage.CREDENTIALS:
				sequence_Credentials(context, (Credentials) semanticObject); 
				return; 
			case WorkflowPackage.DATA_DICTIONARY:
				sequence_DataDictionary(context, (DataDictionary) semanticObject); 
				return; 
			case WorkflowPackage.DATA_PROCESSING:
				sequence_DataProcessing(context, (DataProcessing) semanticObject); 
				return; 
			case WorkflowPackage.DATABASE:
				sequence_Database(context, (Database) semanticObject); 
				return; 
			case WorkflowPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case WorkflowPackage.DATE_RANGE:
				sequence_DateRange(context, (DateRange) semanticObject); 
				return; 
			case WorkflowPackage.DERIVED_FIELD:
				sequence_DerivedField(context, (DerivedField) semanticObject); 
				return; 
			case WorkflowPackage.DERIVED_VALUE:
				sequence_DerivedValue(context, (DerivedValue) semanticObject); 
				return; 
			case WorkflowPackage.DEVELOPMENT_TOOL:
				sequence_DevelopmentTool(context, (DevelopmentTool) semanticObject); 
				return; 
			case WorkflowPackage.DISCRETIZE_BIN:
				sequence_DiscretizeBin(context, (DiscretizeBin) semanticObject); 
				return; 
			case WorkflowPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case WorkflowPackage.FIELD_RANGE:
				sequence_FieldRange(context, (FieldRange) semanticObject); 
				return; 
			case WorkflowPackage.FILE:
				sequence_File(context, (File) semanticObject); 
				return; 
			case WorkflowPackage.FILTER_VALUE:
				sequence_FilterValue(context, (FilterValue) semanticObject); 
				return; 
			case WorkflowPackage.FIX_VALUE:
				sequence_FixValue(context, (FixValue) semanticObject); 
				return; 
			case WorkflowPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case WorkflowPackage.INTERVAL_DATE:
				sequence_IntervalDate(context, (IntervalDate) semanticObject); 
				return; 
			case WorkflowPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case WorkflowPackage.LINK:
				sequence_Link(context, (Link) semanticObject); 
				return; 
			case WorkflowPackage.LOCAL:
				sequence_Local(context, (Local) semanticObject); 
				return; 
			case WorkflowPackage.LOCAL_FOLDER:
				sequence_LocalFolder(context, (LocalFolder) semanticObject); 
				return; 
			case WorkflowPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case WorkflowPackage.MATH_OP:
				sequence_MathOp(context, (MathOp) semanticObject); 
				return; 
			case WorkflowPackage.NUM_OP:
				sequence_NumOp(context, (NumOp) semanticObject); 
				return; 
			case WorkflowPackage.OAUTH2:
				sequence_OAuth2(context, (OAuth2) semanticObject); 
				return; 
			case WorkflowPackage.PMML_MODEL:
				sequence_PMMLModel(context, (PMMLModel) semanticObject); 
				return; 
			case WorkflowPackage.PRIMITIVE:
				sequence_Primitive(context, (Primitive) semanticObject); 
				return; 
			case WorkflowPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case WorkflowPackage.SSL:
				sequence_SSL(context, (SSL) semanticObject); 
				return; 
			case WorkflowPackage.SPECIAL_VALUES:
				sequence_SpecialValues(context, (SpecialValues) semanticObject); 
				return; 
			case WorkflowPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case WorkflowPackage.TEST:
				sequence_Test(context, (Test) semanticObject); 
				return; 
			case WorkflowPackage.VALUE_FIELD:
				sequence_ValueField(context, (ValueField) semanticObject); 
				return; 
			case WorkflowPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Authentication returns AWS
	 *     AWS returns AWS
	 *
	 * Constraint:
	 *     (region=STRING accessKey=STRING endpointURL=STRING secretId=STRING)
	 * </pre>
	 */
	protected void sequence_AWS(ISerializationContext context, AWS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.AWS__REGION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.AWS__REGION));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.AWS__ACCESS_KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.AWS__ACCESS_KEY));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.AWS__ENDPOINT_URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.AWS__ENDPOINT_URL));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.AWS__SECRET_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.AWS__SECRET_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAWSAccess().getRegionSTRINGTerminalRuleCall_3_0(), semanticObject.getRegion());
		feeder.accept(grammarAccess.getAWSAccess().getAccessKeySTRINGTerminalRuleCall_5_0(), semanticObject.getAccessKey());
		feeder.accept(grammarAccess.getAWSAccess().getEndpointURLSTRINGTerminalRuleCall_7_0(), semanticObject.getEndpointURL());
		feeder.accept(grammarAccess.getAWSAccess().getSecretIdSTRINGTerminalRuleCall_9_0(), semanticObject.getSecretId());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Environment returns AmazonECS
	 *     AmazonECS returns AmazonECS
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         path=STRING 
	 *         storage+=Storage+ 
	 *         containerName=STRING 
	 *         developmentTool=DevelopmentTool 
	 *         imageName=STRING 
	 *         imageTag=STRING 
	 *         secretId=STRING 
	 *         region=STRING 
	 *         key=STRING
	 *     )
	 * </pre>
	 */
	protected void sequence_AmazonECS(ISerializationContext context, AmazonECS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Storage returns AmazonS3
	 *     Folder returns AmazonS3
	 *     AmazonS3 returns AmazonS3
	 *
	 * Constraint:
	 *     (
	 *         storageName=ID 
	 *         folderPath=STRING 
	 *         file+=File+ 
	 *         bucket=STRING 
	 *         region=STRING 
	 *         secretId=STRING
	 *     )
	 * </pre>
	 */
	protected void sequence_AmazonS3(ISerializationContext context, AmazonS3 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Storage returns AzureBlob
	 *     Folder returns AzureBlob
	 *     AzureBlob returns AzureBlob
	 *
	 * Constraint:
	 *     (
	 *         storageName=ID 
	 *         folderPath=STRING 
	 *         file+=File+ 
	 *         container=STRING 
	 *         keyVaultName=STRING 
	 *         secretName=STRING
	 *     )
	 * </pre>
	 */
	protected void sequence_AzureBlob(ISerializationContext context, AzureBlob semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Environment returns AzureCI
	 *     AzureCI returns AzureCI
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         path=STRING 
	 *         storage+=Storage+ 
	 *         containerName=STRING 
	 *         developmentTool=DevelopmentTool 
	 *         imageName=STRING 
	 *         imageTag=STRING 
	 *         acrName=STRING 
	 *         keyVaultName=STRING 
	 *         secretName=STRING 
	 *         blobName=STRING
	 *     )
	 * </pre>
	 */
	protected void sequence_AzureCI(ISerializationContext context, AzureCI semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns CastType
	 *     CastType returns CastType
	 *
	 * Constraint:
	 *     (imp_name=ID castTypeDef=ID type=DataType)
	 * </pre>
	 */
	protected void sequence_CastType(ISerializationContext context, CastType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.CAST_TYPE__IMP_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.CAST_TYPE__IMP_NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.CAST_TYPE__CAST_TYPE_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.CAST_TYPE__CAST_TYPE_DEF));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.CAST_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.CAST_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCastTypeAccess().getImp_nameIDTerminalRuleCall_1_0(), semanticObject.getImp_name());
		feeder.accept(grammarAccess.getCastTypeAccess().getCastTypeDefIDTerminalRuleCall_4_0(), semanticObject.getCastTypeDef());
		feeder.accept(grammarAccess.getCastTypeAccess().getTypeDataTypeEnumRuleCall_6_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Argument returns Categorical
	 *     DataField returns Categorical
	 *     Categorical returns Categorical
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         categoricalDef=ID 
	 *         id?='true'? 
	 *         dataType=DataType 
	 *         target?='true'? 
	 *         displayName=STRING? 
	 *         ordinal?='true'? 
	 *         validValues+=ValueField* 
	 *         invalidValues+=ValueField* 
	 *         missingValues+=ValueField*
	 *     )
	 * </pre>
	 */
	protected void sequence_Categorical(ISerializationContext context, Categorical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Argument returns Continuous
	 *     DataField returns Continuous
	 *     Continuous returns Continuous
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         continuousDef=ID 
	 *         id?='true'? 
	 *         dataType=DataType 
	 *         target?='true'? 
	 *         displayName=STRING? 
	 *         numDecimals=EInt? 
	 *         interval+=Interval+ 
	 *         validValues+=ValueField* 
	 *         invalidValues+=ValueField* 
	 *         missingValues+=ValueField*
	 *     )
	 * </pre>
	 */
	protected void sequence_Continuous(ISerializationContext context, Continuous semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (name=ID contractDefinition=ID contract=ContractElement)
	 * </pre>
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.CONTRACT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.CONTRACT__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.CONTRACT__CONTRACT_DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.CONTRACT__CONTRACT_DEFINITION));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.CONTRACT__CONTRACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.CONTRACT__CONTRACT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContractAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getContractAccess().getContractDefinitionIDTerminalRuleCall_4_0(), semanticObject.getContractDefinition());
		feeder.accept(grammarAccess.getContractAccess().getContractContractElementParserRuleCall_6_0(), semanticObject.getContract());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Authentication returns Credentials
	 *     Credentials returns Credentials
	 *
	 * Constraint:
	 *     (username=STRING passwd=STRING)
	 * </pre>
	 */
	protected void sequence_Credentials(ISerializationContext context, Credentials semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.CREDENTIALS__USERNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.CREDENTIALS__USERNAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.CREDENTIALS__PASSWD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.CREDENTIALS__PASSWD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCredentialsAccess().getUsernameSTRINGTerminalRuleCall_3_0(), semanticObject.getUsername());
		feeder.accept(grammarAccess.getCredentialsAccess().getPasswdSTRINGTerminalRuleCall_5_0(), semanticObject.getPasswd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Argument returns DataDictionary
	 *     DataDictionary returns DataDictionary
	 *
	 * Constraint:
	 *     (name=ID dataDictionaryDefinition=ID fileName=STRING? datafield+=DataField*)
	 * </pre>
	 */
	protected void sequence_DataDictionary(ISerializationContext context, DataDictionary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProcessingStep returns DataProcessing
	 *     DataProcessing returns DataProcessing
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         dataProcessingDefinition=ID 
	 *         origin_function=STRING 
	 *         inputPort+=DataDictionary+ 
	 *         outputPort+=DataDictionary+ 
	 *         in+=[Argument|ID]* 
	 *         out+=[Argument|ID]* 
	 *         parameter+=Parameter* 
	 *         contract+=Contract* 
	 *         initial_accumulated_processing=[DataProcessing|ID]?
	 *     )
	 * </pre>
	 */
	protected void sequence_DataProcessing(ISerializationContext context, DataProcessing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Storage returns Database
	 *     Database returns Database
	 *
	 * Constraint:
	 *     (
	 *         storageName=ID 
	 *         host=STRING 
	 *         port=STRING 
	 *         type=DBTYPE 
	 *         auth=Authentication 
	 *         dbName=STRING 
	 *         table+=Table+
	 *     )
	 * </pre>
	 */
	protected void sequence_Database(ISerializationContext context, Database semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MatchingValue returns DateRange
	 *     DateRange returns DateRange
	 *
	 * Constraint:
	 *     (name=ID rangeDef=ID min=STRING max=STRING clousure=ClosureType?)
	 * </pre>
	 */
	protected void sequence_DateRange(ISerializationContext context, DateRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Argument returns Date
	 *     DataField returns Date
	 *     Date returns Date
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         dateDef=ID 
	 *         id?='true'? 
	 *         dataType=DataType 
	 *         target?='true'? 
	 *         displayName=STRING? 
	 *         format=STRING? 
	 *         intervaldate+=IntervalDate+ 
	 *         validValues+=ValueField* 
	 *         invalidValues+=ValueField* 
	 *         missingValues+=ValueField*
	 *     )
	 * </pre>
	 */
	protected void sequence_Date(ISerializationContext context, Date semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns DerivedField
	 *     DerivedField returns DerivedField
	 *
	 * Constraint:
	 *     (name=ID derivedFieldDef=ID der_dataField=[DataField|ID])
	 * </pre>
	 */
	protected void sequence_DerivedField(ISerializationContext context, DerivedField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.DERIVED_FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.DERIVED_FIELD__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.DERIVED_FIELD__DERIVED_FIELD_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.DERIVED_FIELD__DERIVED_FIELD_DEF));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.DERIVED_FIELD__DER_DATA_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.DERIVED_FIELD__DER_DATA_FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDerivedFieldAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDerivedFieldAccess().getDerivedFieldDefIDTerminalRuleCall_4_0(), semanticObject.getDerivedFieldDef());
		feeder.accept(grammarAccess.getDerivedFieldAccess().getDer_dataFieldDataFieldIDTerminalRuleCall_6_0_1(), semanticObject.eGet(WorkflowPackage.Literals.DERIVED_FIELD__DER_DATA_FIELD, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns DerivedValue
	 *     ImputeType returns DerivedValue
	 *     DerivedValue returns DerivedValue
	 *
	 * Constraint:
	 *     (imp_name=ID derivedValueDef=ID type=DerivedType imputeValue=SpecialValue?)
	 * </pre>
	 */
	protected void sequence_DerivedValue(ISerializationContext context, DerivedValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DevelopmentTool returns DevelopmentTool
	 *
	 * Constraint:
	 *     (version=STRING tool=TOOL)
	 * </pre>
	 */
	protected void sequence_DevelopmentTool(ISerializationContext context, DevelopmentTool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.DEVELOPMENT_TOOL__VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.DEVELOPMENT_TOOL__VERSION));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.DEVELOPMENT_TOOL__TOOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.DEVELOPMENT_TOOL__TOOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDevelopmentToolAccess().getVersionSTRINGTerminalRuleCall_3_0(), semanticObject.getVersion());
		feeder.accept(grammarAccess.getDevelopmentToolAccess().getToolTOOLEnumRuleCall_5_0(), semanticObject.getTool());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns DiscretizeBin
	 *     DiscretizeBin returns DiscretizeBin
	 *
	 * Constraint:
	 *     (name=ID discretizeBinDef=ID binValue=STRING interval+=Interval+)
	 * </pre>
	 */
	protected void sequence_DiscretizeBin(ISerializationContext context, DiscretizeBin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns FieldRange
	 *     FieldRange returns FieldRange
	 *
	 * Constraint:
	 *     (name=ID fieldDef=ID dataField+=[DataField|ID]+ operator=Operator)
	 * </pre>
	 */
	protected void sequence_FieldRange(ISerializationContext context, FieldRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operand returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=ID fieldDef=ID datafield=[DataField|ID])
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.OPERAND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.OPERAND__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.FIELD__FIELD_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.FIELD__FIELD_DEF));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.FIELD__DATAFIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.FIELD__DATAFIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldAccess().getFieldDefIDTerminalRuleCall_4_0(), semanticObject.getFieldDef());
		feeder.accept(grammarAccess.getFieldAccess().getDatafieldDataFieldIDTerminalRuleCall_6_0_1(), semanticObject.eGet(WorkflowPackage.Literals.FIELD__DATAFIELD, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Source returns File
	 *     File returns File
	 *
	 * Constraint:
	 *     (
	 *         type=FileType 
	 *         dataDictionary=[DataDictionary|ID] 
	 *         csv_sep=STRING? 
	 *         hdf5_key=STRING? 
	 *         csv_thousandsSep=STRING? 
	 *         csv_decimalSep=STRING?
	 *     )
	 * </pre>
	 */
	protected void sequence_File(ISerializationContext context, File semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns FilterValue
	 *     FilterValue returns FilterValue
	 *
	 * Constraint:
	 *     (name=ID filterValueDef=ID primitive+=Primitive* matchingvalue+=MatchingValue* filterType=FilterType?)
	 * </pre>
	 */
	protected void sequence_FilterValue(ISerializationContext context, FilterValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns FixValue
	 *     Operand returns FixValue
	 *     FixValue returns FixValue
	 *     ImputeType returns FixValue
	 *
	 * Constraint:
	 *     (name=ID fixValueDef=ID value=Primitive)
	 * </pre>
	 */
	protected void sequence_FixValue(ISerializationContext context, FixValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.OPERAND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.OPERAND__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.FIX_VALUE__FIX_VALUE_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.FIX_VALUE__FIX_VALUE_DEF));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.FIX_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.FIX_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFixValueAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFixValueAccess().getFixValueDefIDTerminalRuleCall_4_0(), semanticObject.getFixValueDef());
		feeder.accept(grammarAccess.getFixValueAccess().getValuePrimitiveParserRuleCall_6_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntervalDate returns IntervalDate
	 *
	 * Constraint:
	 *     (leftMargin=STRING rightMargin=STRING clousure=ClosureType?)
	 * </pre>
	 */
	protected void sequence_IntervalDate(ISerializationContext context, IntervalDate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     (leftMargin=EFloat rightMargin=EFloat clousure=ClosureType?)
	 * </pre>
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (name=ID joinDef=ID operand+=Operand+)
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns Link
	 *
	 * Constraint:
	 *     (name=ID source=[ProcessingStep|ID] target=[ProcessingStep|ID])
	 * </pre>
	 */
	protected void sequence_Link(ISerializationContext context, Link semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.LINK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.LINK__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.LINK__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.LINK__SOURCE));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.LINK__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.LINK__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinkAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLinkAccess().getSourceProcessingStepIDTerminalRuleCall_4_0_1(), semanticObject.eGet(WorkflowPackage.Literals.LINK__SOURCE, false));
		feeder.accept(grammarAccess.getLinkAccess().getTargetProcessingStepIDTerminalRuleCall_6_0_1(), semanticObject.eGet(WorkflowPackage.Literals.LINK__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Storage returns LocalFolder
	 *     Folder returns LocalFolder
	 *     LocalFolder returns LocalFolder
	 *
	 * Constraint:
	 *     (storageName=ID folderPath=STRING file+=File+)
	 * </pre>
	 */
	protected void sequence_LocalFolder(ISerializationContext context, LocalFolder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Environment returns Local
	 *     Local returns Local
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         path=STRING 
	 *         storage+=Storage+ 
	 *         containerName=STRING 
	 *         developmentTool=DevelopmentTool 
	 *         imageName=STRING 
	 *         imageTag=STRING
	 *     )
	 * </pre>
	 */
	protected void sequence_Local(ISerializationContext context, Local semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Map
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (name=ID mapDefinition=ID inValue=STRING outvalue=STRING mapOperation=MapOperation)
	 * </pre>
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.MAP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.MAP__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.MAP__MAP_DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.MAP__MAP_DEFINITION));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.MAP__IN_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.MAP__IN_VALUE));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.MAP__OUTVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.MAP__OUTVALUE));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.MAP__MAP_OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.MAP__MAP_OPERATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMapAccess().getMapDefinitionIDTerminalRuleCall_4_0(), semanticObject.getMapDefinition());
		feeder.accept(grammarAccess.getMapAccess().getInValueSTRINGTerminalRuleCall_6_0(), semanticObject.getInValue());
		feeder.accept(grammarAccess.getMapAccess().getOutvalueSTRINGTerminalRuleCall_8_0(), semanticObject.getOutvalue());
		feeder.accept(grammarAccess.getMapAccess().getMapOperationMapOperationEnumRuleCall_10_0(), semanticObject.getMapOperation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns MathOp
	 *     MathOp returns MathOp
	 *
	 * Constraint:
	 *     (name=ID mathOpDef=ID operator=MathOperator operand+=Operand operand+=Operand)
	 * </pre>
	 */
	protected void sequence_MathOp(ISerializationContext context, MathOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns NumOp
	 *     ImputeType returns NumOp
	 *     NumOp returns NumOp
	 *
	 * Constraint:
	 *     (imp_name=ID numOpDef=ID operation=Operation imputeValue=SpecialValue?)
	 * </pre>
	 */
	protected void sequence_NumOp(ISerializationContext context, NumOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Authentication returns OAuth2
	 *     OAuth2 returns OAuth2
	 *
	 * Constraint:
	 *     (clientId=STRING clientSecret=STRING tokenUrl=STRING accessToken=STRING scope=STRING)
	 * </pre>
	 */
	protected void sequence_OAuth2(ISerializationContext context, OAuth2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.OAUTH2__CLIENT_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.OAUTH2__CLIENT_ID));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.OAUTH2__CLIENT_SECRET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.OAUTH2__CLIENT_SECRET));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.OAUTH2__TOKEN_URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.OAUTH2__TOKEN_URL));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.OAUTH2__ACCESS_TOKEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.OAUTH2__ACCESS_TOKEN));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.OAUTH2__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.OAUTH2__SCOPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOAuth2Access().getClientIdSTRINGTerminalRuleCall_3_0(), semanticObject.getClientId());
		feeder.accept(grammarAccess.getOAuth2Access().getClientSecretSTRINGTerminalRuleCall_5_0(), semanticObject.getClientSecret());
		feeder.accept(grammarAccess.getOAuth2Access().getTokenUrlSTRINGTerminalRuleCall_7_0(), semanticObject.getTokenUrl());
		feeder.accept(grammarAccess.getOAuth2Access().getAccessTokenSTRINGTerminalRuleCall_9_0(), semanticObject.getAccessToken());
		feeder.accept(grammarAccess.getOAuth2Access().getScopeSTRINGTerminalRuleCall_11_0(), semanticObject.getScope());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProcessingStep returns PMMLModel
	 *     PMMLModel returns PMMLModel
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         dataProcessingDefinition=ID 
	 *         origin_function=STRING 
	 *         inputPort+=DataDictionary+ 
	 *         outputPort+=DataDictionary+ 
	 *         in+=[Argument|ID]* 
	 *         out+=[Argument|ID]* 
	 *         filePath=STRING 
	 *         onlyPredictions?='true'? 
	 *         test=Test?
	 *     )
	 * </pre>
	 */
	protected void sequence_PMMLModel(ISerializationContext context, PMMLModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Primitive
	 *     Primitive returns Primitive
	 *
	 * Constraint:
	 *     (name=ID primitiveDef=ID value=STRING dataType=LibDataType)
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, Primitive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.PRIMITIVE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.PRIMITIVE__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.PRIMITIVE__PRIMITIVE_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.PRIMITIVE__PRIMITIVE_DEF));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.PRIMITIVE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.PRIMITIVE__VALUE));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.PRIMITIVE__DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.PRIMITIVE__DATA_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPrimitiveAccess().getPrimitiveDefIDTerminalRuleCall_4_0(), semanticObject.getPrimitiveDef());
		feeder.accept(grammarAccess.getPrimitiveAccess().getValueSTRINGTerminalRuleCall_6_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getPrimitiveAccess().getDataTypeLibDataTypeEnumRuleCall_8_0(), semanticObject.getDataType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MatchingValue returns Range
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         rangeDef=ID 
	 *         min=EFloat 
	 *         max=EFloat 
	 *         clousure=ClosureType? 
	 *         minInfinity?='true'? 
	 *         maxInfinity?='true'?
	 *     )
	 * </pre>
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Authentication returns SSL
	 *     SSL returns SSL
	 *
	 * Constraint:
	 *     (path_sslcert=STRING path_sslkey=STRING path_sslrootcert=STRING)
	 * </pre>
	 */
	protected void sequence_SSL(ISerializationContext context, SSL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.SSL__PATH_SSLCERT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.SSL__PATH_SSLCERT));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.SSL__PATH_SSLKEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.SSL__PATH_SSLKEY));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.SSL__PATH_SSLROOTCERT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.SSL__PATH_SSLROOTCERT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSSLAccess().getPath_sslcertSTRINGTerminalRuleCall_3_0(), semanticObject.getPath_sslcert());
		feeder.accept(grammarAccess.getSSLAccess().getPath_sslkeySTRINGTerminalRuleCall_5_0(), semanticObject.getPath_sslkey());
		feeder.accept(grammarAccess.getSSLAccess().getPath_sslrootcertSTRINGTerminalRuleCall_7_0(), semanticObject.getPath_sslrootcert());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MatchingValue returns SpecialValues
	 *     SpecialValues returns SpecialValues
	 *
	 * Constraint:
	 *     (name=ID specialValuesDef=ID specialType=SpecialValue)
	 * </pre>
	 */
	protected void sequence_SpecialValues(ISerializationContext context, SpecialValues semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.MATCHING_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.MATCHING_VALUE__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.SPECIAL_VALUES__SPECIAL_VALUES_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.SPECIAL_VALUES__SPECIAL_VALUES_DEF));
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.SPECIAL_VALUES__SPECIAL_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.SPECIAL_VALUES__SPECIAL_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpecialValuesAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSpecialValuesAccess().getSpecialValuesDefIDTerminalRuleCall_4_0(), semanticObject.getSpecialValuesDef());
		feeder.accept(grammarAccess.getSpecialValuesAccess().getSpecialTypeSpecialValueEnumRuleCall_6_0(), semanticObject.getSpecialType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Source returns Table
	 *     Table returns Table
	 *
	 * Constraint:
	 *     dataDictionary=[DataDictionary|ID]
	 * </pre>
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowPackage.Literals.SOURCE__DATA_DICTIONARY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowPackage.Literals.SOURCE__DATA_DICTIONARY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableAccess().getDataDictionaryDataDictionaryIDTerminalRuleCall_3_0_1(), semanticObject.eGet(WorkflowPackage.Literals.SOURCE__DATA_DICTIONARY, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Test returns Test
	 *
	 * Constraint:
	 *     (path=STRING trainSize=EFloat? testSize=EFloat?)
	 * </pre>
	 */
	protected void sequence_Test(ISerializationContext context, Test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueField returns ValueField
	 *
	 * Constraint:
	 *     (value=STRING count=EInt?)
	 * </pre>
	 */
	protected void sequence_ValueField(ISerializationContext context, ValueField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (name=ID environment=Environment? dataprocessing+=ProcessingStep+ link+=Link*)
	 * </pre>
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
