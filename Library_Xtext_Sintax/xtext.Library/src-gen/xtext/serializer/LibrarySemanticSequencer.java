/*
 * generated by Xtext 2.39.0
 */
package xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.library.CastTypeDef;
import xtext.library.CategoricalDef;
import xtext.library.ConditionDef;
import xtext.library.ContinuousDef;
import xtext.library.ContractDefinition;
import xtext.library.DataDictionaryDefinition;
import xtext.library.DateDef;
import xtext.library.DateRangeDef;
import xtext.library.DerivedFieldDef;
import xtext.library.DerivedValueDef;
import xtext.library.DiscretizeBinDef;
import xtext.library.FieldDef;
import xtext.library.FieldRangeDef;
import xtext.library.FieldRangeDefinition;
import xtext.library.FilterValueDef;
import xtext.library.FixValueDef;
import xtext.library.Job;
import xtext.library.JoinDef;
import xtext.library.Library;
import xtext.library.LibraryPackage;
import xtext.library.MapDef;
import xtext.library.MathOpDef;
import xtext.library.MissingValuesDef;
import xtext.library.NumOpDef;
import xtext.library.PrimitiveDef;
import xtext.library.RangeDef;
import xtext.library.Transformation;
import xtext.library.ValueRangeDefinition;
import xtext.services.LibraryGrammarAccess;

@SuppressWarnings("all")
public class LibrarySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LibraryGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LibraryPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LibraryPackage.CAST_TYPE_DEF:
				sequence_CastTypeDef(context, (CastTypeDef) semanticObject); 
				return; 
			case LibraryPackage.CATEGORICAL_DEF:
				sequence_CategoricalDef(context, (CategoricalDef) semanticObject); 
				return; 
			case LibraryPackage.CONDITION_DEF:
				sequence_ConditionDef(context, (ConditionDef) semanticObject); 
				return; 
			case LibraryPackage.CONTINUOUS_DEF:
				sequence_ContinuousDef(context, (ContinuousDef) semanticObject); 
				return; 
			case LibraryPackage.CONTRACT_DEFINITION:
				sequence_ContractDefinition(context, (ContractDefinition) semanticObject); 
				return; 
			case LibraryPackage.DATA_DICTIONARY_DEFINITION:
				sequence_DataDictionaryDefinition(context, (DataDictionaryDefinition) semanticObject); 
				return; 
			case LibraryPackage.DATE_DEF:
				sequence_DateDef(context, (DateDef) semanticObject); 
				return; 
			case LibraryPackage.DATE_RANGE_DEF:
				sequence_DateRangeDef(context, (DateRangeDef) semanticObject); 
				return; 
			case LibraryPackage.DERIVED_FIELD_DEF:
				sequence_DerivedFieldDef(context, (DerivedFieldDef) semanticObject); 
				return; 
			case LibraryPackage.DERIVED_VALUE_DEF:
				sequence_DerivedValueDef(context, (DerivedValueDef) semanticObject); 
				return; 
			case LibraryPackage.DISCRETIZE_BIN_DEF:
				sequence_DiscretizeBinDef(context, (DiscretizeBinDef) semanticObject); 
				return; 
			case LibraryPackage.FIELD_DEF:
				sequence_FieldDef(context, (FieldDef) semanticObject); 
				return; 
			case LibraryPackage.FIELD_RANGE_DEF:
				sequence_FieldRangeDef(context, (FieldRangeDef) semanticObject); 
				return; 
			case LibraryPackage.FIELD_RANGE_DEFINITION:
				sequence_FieldRangeDefinition(context, (FieldRangeDefinition) semanticObject); 
				return; 
			case LibraryPackage.FILTER_VALUE_DEF:
				sequence_FilterValueDef(context, (FilterValueDef) semanticObject); 
				return; 
			case LibraryPackage.FIX_VALUE_DEF:
				sequence_FixValueDef(context, (FixValueDef) semanticObject); 
				return; 
			case LibraryPackage.JOB:
				sequence_Job(context, (Job) semanticObject); 
				return; 
			case LibraryPackage.JOIN_DEF:
				sequence_JoinDef(context, (JoinDef) semanticObject); 
				return; 
			case LibraryPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case LibraryPackage.MAP_DEF:
				sequence_MapDef(context, (MapDef) semanticObject); 
				return; 
			case LibraryPackage.MATH_OP_DEF:
				sequence_MathOpDef(context, (MathOpDef) semanticObject); 
				return; 
			case LibraryPackage.MISSING_VALUES_DEF:
				sequence_MissingValuesDef(context, (MissingValuesDef) semanticObject); 
				return; 
			case LibraryPackage.NUM_OP_DEF:
				sequence_NumOpDef(context, (NumOpDef) semanticObject); 
				return; 
			case LibraryPackage.PRIMITIVE_DEF:
				sequence_PrimitiveDef(context, (PrimitiveDef) semanticObject); 
				return; 
			case LibraryPackage.RANGE_DEF:
				sequence_RangeDef(context, (RangeDef) semanticObject); 
				return; 
			case LibraryPackage.TRANSFORMATION:
				sequence_Transformation(context, (Transformation) semanticObject); 
				return; 
			case LibraryPackage.VALUE_RANGE_DEFINITION:
				sequence_ValueRangeDefinition(context, (ValueRangeDefinition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns CastTypeDef
	 *     CastTypeDef returns CastTypeDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_CastTypeDef(ISerializationContext context, CastTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArgumentDefinition returns CategoricalDef
	 *     DataFieldDefinition returns CategoricalDef
	 *     CategoricalDef returns CategoricalDef
	 *
	 * Constraint:
	 *     (name=EString boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_CategoricalDef(ISerializationContext context, CategoricalDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractDefinition0 returns ConditionDef
	 *     ConditionDef returns ConditionDef
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_ConditionDef(ISerializationContext context, ConditionDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LibraryPackage.Literals.CONTRACT_DEFINITION0__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LibraryPackage.Literals.CONTRACT_DEFINITION0__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionDefAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArgumentDefinition returns ContinuousDef
	 *     DataFieldDefinition returns ContinuousDef
	 *     ContinuousDef returns ContinuousDef
	 *
	 * Constraint:
	 *     (name=EString boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_ContinuousDef(ISerializationContext context, ContinuousDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractDefinition returns ContractDefinition
	 *
	 * Constraint:
	 *     (name=EString boundTo=EString? contractDefinition=ContractDefinition0)
	 * </pre>
	 */
	protected void sequence_ContractDefinition(ISerializationContext context, ContractDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArgumentDefinition returns DataDictionaryDefinition
	 *     DataDictionaryDefinition returns DataDictionaryDefinition
	 *
	 * Constraint:
	 *     (name=EString boundTo=EString? (datafielddefinition+=DataFieldDefinition datafielddefinition+=DataFieldDefinition*)?)
	 * </pre>
	 */
	protected void sequence_DataDictionaryDefinition(ISerializationContext context, DataDictionaryDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArgumentDefinition returns DateDef
	 *     DataFieldDefinition returns DateDef
	 *     DateDef returns DateDef
	 *
	 * Constraint:
	 *     (name=EString boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_DateDef(ISerializationContext context, DateDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns DateRangeDef
	 *     MatchingValueDef returns DateRangeDef
	 *     DateRangeDef returns DateRangeDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_DateRangeDef(ISerializationContext context, DateRangeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns DerivedFieldDef
	 *     DerivedFieldDef returns DerivedFieldDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_DerivedFieldDef(ISerializationContext context, DerivedFieldDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns DerivedValueDef
	 *     DerivedValueDef returns DerivedValueDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_DerivedValueDef(ISerializationContext context, DerivedValueDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns DiscretizeBinDef
	 *     DiscretizeBinDef returns DiscretizeBinDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_DiscretizeBinDef(ISerializationContext context, DiscretizeBinDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns FieldDef
	 *     OperandDef returns FieldDef
	 *     FieldDef returns FieldDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString? datafielddefinition=[DataFieldDefinition|EString])
	 * </pre>
	 */
	protected void sequence_FieldDef(ISerializationContext context, FieldDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns FieldRangeDef
	 *     FieldRangeDef returns FieldRangeDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_FieldRangeDef(ISerializationContext context, FieldRangeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractDefinition0 returns FieldRangeDefinition
	 *     FieldRangeDefinition returns FieldRangeDefinition
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_FieldRangeDefinition(ISerializationContext context, FieldRangeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LibraryPackage.Literals.CONTRACT_DEFINITION0__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LibraryPackage.Literals.CONTRACT_DEFINITION0__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldRangeDefinitionAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns FilterValueDef
	 *     FilterValueDef returns FilterValueDef
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         required=EBoolean? 
	 *         boundTo=EString? 
	 *         (matchingvaluedef+=MatchingValueDef matchingvaluedef+=MatchingValueDef*)? 
	 *         (primitivedef+=PrimitiveDef primitivedef+=PrimitiveDef*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_FilterValueDef(ISerializationContext context, FilterValueDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns FixValueDef
	 *     FixValueDef returns FixValueDef
	 *     OperandDef returns FixValueDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString? value=PrimitiveDef)
	 * </pre>
	 */
	protected void sequence_FixValueDef(ISerializationContext context, FixValueDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataProcessingDefinition returns Job
	 *     Job returns Job
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         in+=[ArgumentDefinition|EString] 
	 *         in+=[ArgumentDefinition|EString]* 
	 *         out+=[ArgumentDefinition|EString] 
	 *         out+=[ArgumentDefinition|EString]* 
	 *         workflow=EString 
	 *         (parameterdefinition+=ParameterDefinition parameterdefinition+=ParameterDefinition*)? 
	 *         (contractdefinition+=ContractDefinition contractdefinition+=ContractDefinition*)? 
	 *         inputPort+=DataDictionaryDefinition 
	 *         inputPort+=DataDictionaryDefinition* 
	 *         outputPort+=DataDictionaryDefinition 
	 *         outputPort+=DataDictionaryDefinition*
	 *     )
	 * </pre>
	 */
	protected void sequence_Job(ISerializationContext context, Job semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns JoinDef
	 *     JoinDef returns JoinDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString? operandDef+=OperandDef operandDef+=OperandDef*)
	 * </pre>
	 */
	protected void sequence_JoinDef(ISerializationContext context, JoinDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Library returns Library
	 *
	 * Constraint:
	 *     (name=EString (dataprocessingdefinition+=DataProcessingDefinition dataprocessingdefinition+=DataProcessingDefinition*)?)
	 * </pre>
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns MapDef
	 *     MapDef returns MapDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_MapDef(ISerializationContext context, MapDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns MathOpDef
	 *     MathOpDef returns MathOpDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString? operandDef+=OperandDef operandDef+=OperandDef*)
	 * </pre>
	 */
	protected void sequence_MathOpDef(ISerializationContext context, MathOpDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns MissingValuesDef
	 *     MatchingValueDef returns MissingValuesDef
	 *     MissingValuesDef returns MissingValuesDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_MissingValuesDef(ISerializationContext context, MissingValuesDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns NumOpDef
	 *     NumOpDef returns NumOpDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_NumOpDef(ISerializationContext context, NumOpDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns PrimitiveDef
	 *     PrimitiveDef returns PrimitiveDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_PrimitiveDef(ISerializationContext context, PrimitiveDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterDefinition returns RangeDef
	 *     MatchingValueDef returns RangeDef
	 *     RangeDef returns RangeDef
	 *
	 * Constraint:
	 *     (name=EString required=EBoolean? boundTo=EString?)
	 * </pre>
	 */
	protected void sequence_RangeDef(ISerializationContext context, RangeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataProcessingDefinition returns Transformation
	 *     Transformation returns Transformation
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         in+=[ArgumentDefinition|EString] 
	 *         in+=[ArgumentDefinition|EString]* 
	 *         out+=[ArgumentDefinition|EString] 
	 *         out+=[ArgumentDefinition|EString]* 
	 *         (parameterdefinition+=ParameterDefinition parameterdefinition+=ParameterDefinition*)? 
	 *         (contractdefinition+=ContractDefinition contractdefinition+=ContractDefinition*)? 
	 *         inputPort+=DataDictionaryDefinition 
	 *         inputPort+=DataDictionaryDefinition* 
	 *         outputPort+=DataDictionaryDefinition 
	 *         outputPort+=DataDictionaryDefinition*
	 *     )
	 * </pre>
	 */
	protected void sequence_Transformation(ISerializationContext context, Transformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractDefinition0 returns ValueRangeDefinition
	 *     ValueRangeDefinition returns ValueRangeDefinition
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_ValueRangeDefinition(ISerializationContext context, ValueRangeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LibraryPackage.Literals.CONTRACT_DEFINITION0__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LibraryPackage.Literals.CONTRACT_DEFINITION0__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueRangeDefinitionAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
