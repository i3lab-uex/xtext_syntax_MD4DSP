/*
 * generated by Xtext 2.40.0
 */
package xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.mm_M4DS.BooleanValue;
import xtext.mm_M4DS.Categorical;
import xtext.mm_M4DS.Condition;
import xtext.mm_M4DS.Continuous;
import xtext.mm_M4DS.Contract;
import xtext.mm_M4DS.DataProcessing;
import xtext.mm_M4DS.DateField;
import xtext.mm_M4DS.Job;
import xtext.mm_M4DS.Library;
import xtext.mm_M4DS.Mm_M4DSPackage;
import xtext.mm_M4DS.Model;
import xtext.mm_M4DS.NumberValue;
import xtext.mm_M4DS.PMMLModel;
import xtext.mm_M4DS.StringValue;
import xtext.mm_M4DS.Transformation;
import xtext.mm_M4DS.Workflow;
import xtext.services.MM_M4DSGrammarAccess;

@SuppressWarnings("all")
public class MM_M4DSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MM_M4DSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Mm_M4DSPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Mm_M4DSPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case Mm_M4DSPackage.CATEGORICAL:
				sequence_Categorical(context, (Categorical) semanticObject); 
				return; 
			case Mm_M4DSPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case Mm_M4DSPackage.CONTINUOUS:
				sequence_Continuous(context, (Continuous) semanticObject); 
				return; 
			case Mm_M4DSPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case Mm_M4DSPackage.DATA_PROCESSING:
				sequence_DataProcessing(context, (DataProcessing) semanticObject); 
				return; 
			case Mm_M4DSPackage.DATE_FIELD:
				sequence_DateField(context, (DateField) semanticObject); 
				return; 
			case Mm_M4DSPackage.JOB:
				sequence_Job(context, (Job) semanticObject); 
				return; 
			case Mm_M4DSPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case Mm_M4DSPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case Mm_M4DSPackage.NUMBER_VALUE:
				sequence_NumberValue(context, (NumberValue) semanticObject); 
				return; 
			case Mm_M4DSPackage.PMML_MODEL:
				sequence_PMMLModel(context, (PMMLModel) semanticObject); 
				return; 
			case Mm_M4DSPackage.PARAMETER:
				sequence_Parameter(context, (xtext.mm_M4DS.Parameter) semanticObject); 
				return; 
			case Mm_M4DSPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case Mm_M4DSPackage.TRANSFORMATION:
				sequence_Transformation(context, (Transformation) semanticObject); 
				return; 
			case Mm_M4DSPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns BooleanValue
	 *     BooleanValue returns BooleanValue
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 * </pre>
	 */
	protected void sequence_BooleanValue(ISerializationContext context, BooleanValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataField returns Categorical
	 *     Categorical returns Categorical
	 *
	 * Constraint:
	 *     (name=ID dataType=DataType? (validValues+=STRING validValues+=STRING*)?)
	 * </pre>
	 */
	protected void sequence_Categorical(ISerializationContext context, Categorical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (name=ID field=[DataField|ID] operator=ComparisonOperator value=Value)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Mm_M4DSPackage.Literals.CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Mm_M4DSPackage.Literals.CONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, Mm_M4DSPackage.Literals.CONDITION__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Mm_M4DSPackage.Literals.CONDITION__FIELD));
			if (transientValues.isValueTransient(semanticObject, Mm_M4DSPackage.Literals.CONDITION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Mm_M4DSPackage.Literals.CONDITION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, Mm_M4DSPackage.Literals.CONDITION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Mm_M4DSPackage.Literals.CONDITION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConditionAccess().getFieldDataFieldIDTerminalRuleCall_4_0_1(), semanticObject.eGet(Mm_M4DSPackage.Literals.CONDITION__FIELD, false));
		feeder.accept(grammarAccess.getConditionAccess().getOperatorComparisonOperatorEnumRuleCall_6_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getConditionAccess().getValueValueParserRuleCall_8_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataField returns Continuous
	 *     Continuous returns Continuous
	 *
	 * Constraint:
	 *     (name=ID dataType=DataType? min=NUMBER? max=NUMBER?)
	 * </pre>
	 */
	protected void sequence_Continuous(ISerializationContext context, Continuous semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Contract
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (name=ID (conditions+=Condition conditions+=Condition*)?)
	 * </pre>
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProcessingStep returns DataProcessing
	 *     DataProcessing returns DataProcessing
	 *
	 * Constraint:
	 *     (name=ID input=DataField output=DataField operation=Operation?)
	 * </pre>
	 */
	protected void sequence_DataProcessing(ISerializationContext context, DataProcessing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataField returns DateField
	 *     DateField returns DateField
	 *
	 * Constraint:
	 *     (name=ID format=STRING?)
	 * </pre>
	 */
	protected void sequence_DateField(ISerializationContext context, DateField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Job returns Job
	 *
	 * Constraint:
	 *     (name=ID input=DataField output=DataField (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_Job(ISerializationContext context, Job semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Library
	 *     Library returns Library
	 *
	 * Constraint:
	 *     (name=ID (jobs+=Job jobs+=Job*)? (transformations+=Transformation transformations+=Transformation*)?)
	 * </pre>
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=Element+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns NumberValue
	 *     NumberValue returns NumberValue
	 *
	 * Constraint:
	 *     value=NUMBER
	 * </pre>
	 */
	protected void sequence_NumberValue(ISerializationContext context, NumberValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Mm_M4DSPackage.Literals.NUMBER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Mm_M4DSPackage.Literals.NUMBER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberValueAccess().getValueNUMBERTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProcessingStep returns PMMLModel
	 *     PMMLModel returns PMMLModel
	 *
	 * Constraint:
	 *     (name=ID filePath=STRING? input=DataField output=DataField)
	 * </pre>
	 */
	protected void sequence_PMMLModel(ISerializationContext context, PMMLModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=DataType value=Value?)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, xtext.mm_M4DS.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns StringValue
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Mm_M4DSPackage.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Mm_M4DSPackage.Literals.STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns Transformation
	 *
	 * Constraint:
	 *     (name=ID input=DataField output=DataField (parameters+=Parameter parameters+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_Transformation(ISerializationContext context, Transformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Workflow
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (steps+=ProcessingStep steps+=ProcessingStep*)? 
	 *         (dataFields+=DataField dataFields+=DataField*)? 
	 *         (contracts+=Contract contracts+=Contract*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
